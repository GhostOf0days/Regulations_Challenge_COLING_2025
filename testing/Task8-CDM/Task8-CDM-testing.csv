Question,Answer
Who owns my project after it's been contributed to FINOS?,"You (or your employer) retains copyright on everything you contribute - the Foundation receives your contribution under a license agreement (i.e. the Foundation's CLA).  We do not require copyright assignment.

Please refer to the contribution page for more details on how the Foundation handles your contribution from a legal perspective."
Why does FINOS use the Apache License? Does our project have to?,"The FINOS Intellectual Property Policy requires that all software projects managed by the Foundation be licensed under the terms of the Apache License 2.0 unless another license is explicitly approved by the Board.

For standard projects the Governing Board has approved the Community Specification process as an approved technical charter.

The Board’s decision to use Apache 2 as the “default” license for FINOS projects was informed primarily by the following characteristics:

It is a permissive license, i.e. it does not require anyone to contribute their modifications back to FINOS. While FINOS recognizes the important role that reciprocal licenses such as the GNU General Public License can play in promoting equity between contributors, our members generally prefer to consume permissively licensed code. We’re confident that the benefits of active participation in FINOS projects are sufficient incentive to contributors.
It’s widely adopted. Apache 2.0 is used by high-profile, commercially significant open source software projects published by open source communities (most notably the Apache Software Foundation) and major corporations (including Google, Apple, GitHub, Facebook, Microsoft, and Adobe). Software IP attorneys (those reviewing licenses for prospective users, contributors, and members) are generally familiar and comfortable with it, as well as with the accompanying Apache Corporate and Individual Contributor License Agreements.
It’s concise and unambiguous. While some free and open source software licenses address political, ethical, and moral issues, reflecting the focus of their authors and users, Apache 2.0 is a straightforward software license raising few interpretive issues. In particular, it explicitly and fairly addresses the licensing of patents: the license from contributors includes any patent claims implicated by their contributions, but not by code contributed by others."
Can I advertise my participation in a FINOS project?,"FINOS enthusiastically encourages contributors to promote their participation in Foundation activities. However, any reference to a FINOS or FINOS project mark must be accurate and not misleading. For example, we do not permit third parties to advertise membership in FINOS projects when they have not actually contributed to them, or to promote adoption of a FINOS standard when their implementation is incomplete. Please review our Trademark Guidelines for more information about permissible uses of FINOS project marks.

In addition, our active participation policy provides that only participants that meet our criteria for “active participation” in a project are entitled to be mentioned as participants or contributors in FINOS’s own promotional materials regarding that project.

Note: The above also applies to the now deprecated concept of Programs."
Are there any FINOS guidelines about company branding in the contributed source code?,"As a rule, contributor trademarks should not appear in project, program, application, or filenames, or anywhere else in project repositories. The exceptions are that they are appropriate in code comments reflecting copyright notices and other appropriate legal notices, commit messages, and lists of contributors (e.g. a CONTRIBUTING or file). Likewise, as stated above, in some circumstances it is appropriate for contributors' names and logos to appear on program/project web pages listing contributors or referring to particular contributions."
"Are Mailing lists open to the public, or is it only visible by participants?","In keeping with the open source nature of the Foundation, public (unauthenticated) archives are available for most email groups at http://groups.google.com/a/finos.org/ (for example, for projects and working groups and PMCs). However, PMCs are provided also with private lists, such as *-pmc-private@finos.org lists to discuss sensitive matters (e.g. alleged Code of Conduct violations). 

Rosters of participants to the mailing lists are only available for members of a specific mailing list at http://groups.google.com/a/finos.org/, provided they have a valid Google account."
"Who can commit to my project, after it's been contributed?","The Foundation maintains a centralized directory of contributors who have a legal framework (CLA) to contribute to FINOS project, but Project Maintainers retain full control over your project, including who has commit rights to the code (with one caveat - see the note at right).  In other words no one can commit directly to your project until / unless you approve them to do so. See how we manage project permissions and collaboration on Github.

Of course you should expect pull requests to come in from anywhere, and you are expected to triage those in a timely fashion.

Note: the Foundation manages a GitHub account (finos-admin) that also has implicit commit rights to your project, by virtue of being the administrator of all Program Github organizations. However Foundation staff do not use this account for repository-level activities except in extraordinary circumstances, and even then will attempt to contact the project team and/or the PMC before doing so."
Does the Foundation provide developers for my project?,"No. Developers (along with systems engineers, designers, product mangers) come from the community. We do though help promote your project to encourage the community to contribute to it via pull requests. Based on the quality and volume of those contributions you may then choose to grant some or all of those contributors commit rights to your project."
Are there any restrictions on how many projects I can host with the Foundation?,"No - we encourage contributors to host as many projects with the Foundation as they wish, provided they go through the contribution process."
What is a good granularity for a project?,"The Foundation prefers projects that are functionally cohesive i.e. that focus on solving a distinct business problem.  While we will accept codebases that contain a number of unrelated solutions, it is probable that such projects will need to be split up into multiple projects in order to be eligible for release.  In these cases any shared code may also need to be refactored into its own repository (see Adding a New Repository to your Project for details on that process), and then consumed via whatever library dependency management mechanism is provided by your language and/or build toolchain."
What are the most commonly used languages across FINOS projects?,"As of July 2019, Javascript (38.5%), Java (34.6%), Python (12.5%) and TypeScript (11.5%) are the most commonly used languages across FINOS projects. See our Project and Working Group Catalogue for more information on languages used across FINOS programs."
What is the proportion of member vs. non-member contributors to FINOS projects?,"As of July 2019, 46% of active contributors are FINOS members, so about half of the active participants come from FINOS members, the other half from non-members participating organizations."
Does FINOS offer compliance tools?,"Yes, you can find information related to this on the Code Validation section."
Can FINOS redistribute binaries to collect community feedback before contributing a project?,"Yes, FINOS can redistribute binaries. We have nuget, npmjs, maven central and pypi repositories for that purpose."
Where can I see the upcoming schedule of FINOS meetings so that I can participate?,"Our Programs Meeting Calendar collects all of our online meetings in a calendar format you can easily add to your personal calendar. Our website events page collects instead all of our in person hosted events and events FINOS participates in, as well as marketplace events relevant to our Community."
Is attendance to FINOS project and SIG meetings open to the public?,"Yes, by default project and SIGs meetings are open to anyone who wishes to participate. However, especially during formation stage, projects and SIGs may choose to restrict attendance based on objective and published criteria, but are still expected to observe the FINOS Collaborative Principles, Meeting Procedures and recommended to follow Branding Guidelines. "
May non project maintainers attend and participate in project meetings?,"Once a project is out of the optional forming stage and enters incubation, it is encouraged to adopt an ""open door"" policy for maximum transparency and inclusion of all contributors. There is nothing in our Governance that restricts attendance to meetings and all meetings in the Foundation have to comply with FINOS Collaborative Principles and Meeting Procedures.
"
"How does product qualification (payout) work, and what attributes influence it?","The Payout type defines the composable payout types, each of which describes a set of terms and conditions for the financial responsibilities between the contractual parties. Payout types can be combined to compose a product. For example, an Equity Swap can be composed by combining an InterestRatePayout and an PerformancePayout.

type Payout:
  [metadata key]
  interestRatePayout InterestRatePayout (0..*)
  creditDefaultPayout CreditDefaultPayout (0..1)
  optionPayout OptionPayout (0..*)
  commodityPayout CommodityPayout (0..*)
  forwardPayout ForwardPayout (0..*)
  fixedPricePayout FixedPricePayout (0..*)
  securityPayout SecurityPayout (0..*)
       [deprecated]
  cashflow Cashflow (0..*)
  performancePayout PerformancePayout (0..*)
  assetPayout AssetPayout (0..*)

A number of payout types extend a common data type called PayoutBase. This data type provides a common structure for attributes such as quantity, price, settlement terms and the payer/receiver direction which are expected to be common across many payouts.

type PayoutBase:
  payerReceiver PayerReceiver (1..1)
  priceQuantity ResolvablePriceQuantity (0..1)
  principalPayment PrincipalPayments (0..1)
  settlementTerms SettlementTerms (0..1)

The list of payouts that extend PayoutBase are:

InterestRatePayout
CreditDefaultPayout
OptionPayout
CommodityPayout
ForwardPayout
FixedPricePayout
SecurityPayout
Cashflow
PerformancePayout
AssetPayout
the ProtectionTerms data type encapsulated in CreditDefaultPayout
For example:

type InterestRatePayout extends PayoutBase:
   [metadata key]
   rateSpecification RateSpecification (0..1)
   dayCountFraction DayCountFractionEnum (0..1)
      [metadata scheme]
   calculationPeriodDates CalculationPeriodDates (0..1)
   paymentDates PaymentDates (0..1)
   paymentDate AdjustableDate (0..1)
   paymentDelay boolean (0..1)
   resetDates ResetDates (0..1)
   discountingMethod DiscountingMethod (0..1)
   compoundingMethod CompoundingMethodEnum (0..1)
   cashflowRepresentation CashflowRepresentation (0..1)
   stubPeriod StubPeriod (0..1)
   bondReference BondReference (0..1)
   fixedAmount calculation (0..1)
   floatingAmount calculation (0..1)

Note: The code snippets above excludes the conditions in this data type for purposes of brevity.

The price and quantity attributes in the PayoutBase structure are positioned in the ResolvablePriceQuantity data type. This data type mirrors the PriceQuantity data type and contains both the price and quantity schedules.

In addition that data type supports the definition of additional information such as a quantity reference, a quantity multiplier or the indication that the quantity is resettable. Those are used to describe the quantity of a payout leg that may need to be calculated based on other inputs: e.g. an exchange rate for the foreign leg in a Cross-Currency Swap or a share price for the funding leg of an Equity Swap.

type ResolvablePriceQuantity:
  [metadata key]
  quantityCumulation CumulationFeature (0..*)
  resolvedQuantity Quantity (0..1)
  quantitySchedule NonNegativeQuantitySchedule (0..1)
    [metadata address ""pointsTo""=PriceQuantity->quantity]
  quantityReference ResolvablePriceQuantity (0..1)
    [metadata reference]
  quantityMultiplier QuantityMultiplier (0..1)
  reset boolean (0..1)
  futureValueNotional FutureValueAmount (0..1)
  priceSchedule PriceSchedule (0..*)
    [metadata address ""pointsTo""=PriceQuantity->price]

By design, the CDM requires that each payout leg can only be associated with a single quantity schedule that defines this leg's contractual behaviour (e.g. for the payment of cashflows). In the PriceQuantity object, where that attribute is of multiple cardinality, other quantities may be provided ""for information only"" which can be inferred from the main quantity used in the payout leg: e.g. when a commodity quantity is associated to a frequency and needs to be multiplied by the period to get the total quantity.

Both the quantitySchedule and priceSchedule attributes have a metadata address that point respectively to the quantity and price attributes in the PriceQuantity data type. This special cross-referencing annotation in the Rosetta DSL allows to parameterise an attribute whose value may be variable by associating it to an address. The attribute value does not need to be populated in the persisted object and can be provided by another object, using the address as a reference.

Other model structures use the [metadata address] to point to PriceQuantity->price. An example include the price attribute in the RateSchedule data type, which is illustrated below:

type RateSchedule:
  price PriceSchedule (1..1)
    [metadata address ""pointsTo""=PriceQuantity->price]"
"How is the lifecycle of a financial product, such as an interest rate swap, represented?","The CDM event model provides data structures to represent the lifecycle events of financial transactions. A lifecycle event occurs when a transaction goes through a state transition initiated either by one or both trading parties, by contractual terms, or by external factors. For example, the execution of a trade is the initial event which results in the state of an executed trade. Subsequently, one party might initiate an allocation, both parties might initiate an amendment to a contractual agreement, or a default by an underlying entity on a Credit Default Swap would trigger a settlement according to defined protection terms.

Examples of lifecycle events supported by the CDM Event Model include the following:

Trade execution and confirmation
Clearing
Allocation
Settlement (including any future contingent cashflow payment)
Exercise of options
The representation of lifecycle events in the CDM is based on the following design principles:

A lifecycle event describes a state transition. There must be different before/after trade states based on that lifecycle event.
State transitions are functional and composable. The CDM specifies the entire functional logic to transition from one state to another. The state transition logic of all in-scope events is obtained by composition from a small set of functional building blocks.
The history of the trade state can be reconstructed at any point in the trade lifecycle. The CDM implements a lineage between states as the trade goes through state transitions.
The product underlying the transaction remains immutable. Automated events, for instance resets or cashflow payments, do not alter the product definition. Lifecycle events negotiated between the parties that give rise to a change in the trade economics generate a new instance of the product or trade as part of that specific event.
The state is trade-specific, not product-specific (i.e. the CDM is not an asset-servicing model). The same product may be associated to infinitely many trades, each with its own specific state, between any two parties."
"What is a WorkflowStep, and how is it related to a business event?","The CDM provides support for implementors to develop workflows to process transaction lifecycle events.

A workflow represents a set of actions or steps that are required to trigger a business event, including the initial execution or contract formation. A workflow is organised into a sequence in which each step is represented by a workflow step. A workflow may involve multiple parties in addition to the parties to the transaction, and may include automated and manual steps. A workflow may involve only one step.

The CDM supports a workflow's audit trail by providing lineage from one step to another in that workflow.

type WorkflowStep:
  [metadata key]
  [rootType]
  businessEvent BusinessEvent (0..1)
  counterpartyPositionBusinessEvent CounterpartyPositionBusinessEvent (0..1)
  proposedEvent EventInstruction (0..1)
  rejected boolean (0..1)
  approval WorkflowStepApproval (0..*)
  previousWorkflowStep WorkflowStep (0..1)
    [metadata reference]
  nextEvent EventInstruction (0..1)
  messageInformation MessageInformation (0..1)
  timestamp EventTimestamp (1..*)
  eventIdentifier Identifier (1..*)
  action ActionEnum (0..1)
  party Party (0..*)
  account Account (0..*)
  lineage Lineage (0..1)
    [deprecated]
  creditLimitInformation CreditLimitInformation (0..1)
  workflowState WorkflowState (0..1)


The different attributes of a workflow step are detailed in the sections below.

Workflow Step Business Event
This attribute specifies the business event that the workflow step is meant to generate. It is optional because the workflow may require a number of interim steps before the state-transition embedded within the business event becomes effective, therefore the business event does not exist yet in those steps. The business event attribute is typically associated with the final step in the workflow."
"What is a Business event, and how is it used in the context of trade processing?","Business event represents a lifecycle event affecting one or more trades as a composite of primitive instructions. A business event can comprise several instructions, each consisting of a set of primitive instructions applied to a single trade state (before). The resulting trade state (after) can be multiple."
"What is a Trade State, and how does it evolve through the lifecycle of a transaction?","Trade state represents the state in the lifecycle that the trade is in, from execution to settlement and maturity."
"How does the qualification of events work, and how can it be related to reporting action types?","The CDM qualifies lifecycle events as a function of their primitive components rather than explicitly declaring the event type. The CDM uses the same approach for event qualification as for product qualification and is based on a set of Event Qualification functions. These functions are identified with a [qualification BusinessEvent] annotatation.

Event Qualification functions apply a taxonomy-specific business logic to identify if the state-transition attributes values, which are embedded in the primitive event components, match the specified criteria for the event named in that taxonomy. Like Product Qualification functions, the Event Qualification function name is prefixed with the word Qualify_ followed by the taxonomy name.

The CDM uses the ISDA taxonomy V2.0 leaf level to qualify the event. 23 lifecycle events have currently been qualified as part of the CDM.

One distinction with the product approach is that the intent qualification is also deemed necessary to complement the primitive event information in certain cases. To this effect, the Event Qualification function allows to specify that when present, the intent must have a specified value, as illustrated by the below example.

func Qualify_Termination:
  [qualification BusinessEvent]
  inputs:
    businessEvent BusinessEvent (1..1)
  output: is_event boolean (1..1)
  alias primitiveInstruction: businessEvent -> instruction -> primitiveInstruction only-element
  alias transfer: TransfersForDate( businessEvent -> after -> transferHistory -> transfer, businessEvent -> eventDate ) only-element

  set is_event:
    businessEvent -> intent is absent
      and (primitiveInstruction -> quantityChange only exists
          or (primitiveInstruction -> quantityChange, primitiveInstruction -> transfer) only exists)
      and (QuantityDecreasedToZero(businessEvent -> instruction -> before, businessEvent -> after) = True)
      and (businessEvent -> after -> state -> closedState -> state all = ClosedStateEnum -> Terminated)


If all the statements above are true, then the function evaluates to True. In this case, the event is determined to be qualified as the event type referenced by the function name.

The output of the qualification function is used to populate the eventQualifier attribute of the BusinessEvent object, similar to how product qualification works. An implementation of the CDM would call all of the Event Qualification functions following the creation of each event and then insert the appropriate value or provide an exception message.

Note: The type of the eventQualifier attribute in BusinessEvent, called eventType, is a meta-type that indicates that its value is meant to be populated using some functional logic. That functional logic must be represented by a qualification function annotated with [qualification BusinessEvent], as in the example above. This mechanism is further detailed in the Rosetta DSL documentation."
How does the qualification of the product work and what are the main ones?,"Product qualification is inferred from the economic terms of the product instead of explicitly naming the product type. The CDM uses a set of Product Qualification functions to achieve this purpose. These functions are identified with a [qualification Product] annotation.

A Product Qualification function applies a taxonomy-specific business logic to identify if the product attribute values, as represented by the product's economic terms, match the specified criteria for the product named in that taxonomy. For example, if a certain set of attributes are populated and others are absent, then that specific product type is inferred. The Product Qualification function name in the CDM begins with the word Qualify followed by an underscore _ and then the product type from the applicable taxonomy (also separated by underscores).

The CDM implements the ISDA Product Taxonomy v2.0 to qualify contractual products, foreign exchange, and repurchase agreements. Given the prevalence of usage of the ISDA Product Taxonomy v1.0, the equivalent name from that taxonomy is also systematically indicated in the CDM, using a synonym annotation displayed under the function output. An example is provided below for the qualification of a Zero-Coupon Fixed-Float Inflation Swap:

func Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon:
  [qualification Product]
  inputs: economicTerms EconomicTerms (1..1)
  output: is_product boolean (1..1)
    [synonym ISDA_Taxonomy_v2 value ""InterestRate_IRSwap_Inflation""]
  set is_product:
    Qualify_BaseProduct_Inflation(economicTerms) = True
    and Qualify_BaseProduct_CrossCurrency( economicTerms ) = False
    and Qualify_SubProduct_FixedFloat(economicTerms) = True
    and Qualify_Transaction_ZeroCoupon(economicTerms) = True


If all the statements above are true, then the function evaluates to True, and the product is determined to be qualified as the product type referenced by the function name.

Note: In a typical CDM model implementation, the full set of Product Qualification functions would be invoked against each instance of the product in order to determine the inferred product type. Given the product model composability, a single product instance may be qualified as more than one type: for example in an Interest Rate Swaption, both the Option and the underlying Interest Rate Swap would be qualified.

The CDM supports Product Qualification functions for Credit Derivatives, Interest Rate Derivatives, Equity Derivatives, Foreign Exchange, and Repurchase Agreements. The full scope for Interest Rate Products has been represented down to the full level of detail in the taxonomy. This is shown in the example above, where the ZeroCoupon qualifying suffix is part of the function name. Credit Default products are qualified, but not down to the full level of detail. The ISDA Product Taxonomy v2.0 references the FpML transaction type field instead of just the product features, whose possible values are not publicly available and hence not positioned as a CDM enumeration.

The output of the qualification function is used to populate the productQualifier attribute of the ProductTaxonomy object, which is created when a ContractualProduct object is created. The product taxonomy includes both the product qualification generated by the CDM and any additional product taxonomy information which may come from the originating document, such as FpML. In this case, taxonomy schemes may be associated to such product taxonomy information, which are also propagated in the ProductTaxonomy object.

Many different financial taxonomies may be used by various segments of the financial industry to describe the same product. To support a multitude of taxonomies without adding any specific identity to data types in the model, a Taxonomy type is used to identify the source and attributes any particular taxonomy structure.

type Taxonomy:
   source TaxonomySourceEnum (0..1)
   value TaxonomyValue (0..1)

TaxonomyValue has been expanded to represent a complex type:

type TaxonomyValue: 

   name string (0..1)
       [metadata scheme]
   classification TaxonomyClassification (0..*)

   condition ValueExists:
       name exists or classification exists

TaxonomyClassification is also a complex type that support a hierarchical structure of any depth:

type TaxonomyClassification:
    className string (0..1)
    value string (1..1)
    description string (0..1)
    ordinal int (0..1)

The ProductTaxonomy data structure and an instance of a CDM object (serialised into JSON) are shown below:

type ProductTaxonomy extends Taxonomy:
    primaryAssetClass AssetClassEnum (0..1)
        [metadata scheme]
    secondaryAssetClass AssetClassEnum (0..*)
        [metadata scheme]
    productQualifier string (0..1)

    condition TaxonomyType:
        required choice source, primaryAssetClass, secondaryAssetClass

    condition TaxonomySource:
        if source exists then ( value exists or productQualifier exists )

    condition TaxonomyValue:
        optional choice value, productQualifier


""productTaxonomy"": [
  {
    ""primaryAssetClass"": {
      ""meta"": {
        ""scheme"": ""http://www.fpml.org/coding-scheme/asset-class-simple""
      },
      ""value"": ""INTEREST_RATE""
    },
  },
  {
    ""taxonomyValue"": {
      ""meta"": {
        ""scheme"": ""http://www.fpml.org/coding-scheme/product-taxonomy""
      },
      ""value"": ""InterestRate:IRSwap:FixedFloat""
    }
    ""taxonomySource"": ""ISDA""
  },
  {
    ""productQualifier"": ""InterestRate_IRSwap_FixedFloat"",
    ""taxonomySource"": ""ISDA""
  }
]"
How does the system ensure data consistency across different lifecycle events of a trade?,"While the lifecycle event model described in the event-model-section provides a standardised data representation of those events using the concept of primitive event components, the CDM must further specify the processing of those events to ensure standardised implementations across the industry. This means specifying the logic of the state-transition as described by each primitive event component.

In particular, the CDM must ensure that:

The lifecycle event process model constructs valid CDM event objects.
The constructed events qualify according to the qualification logic described in the event-qualification-section.
The lineage between states allows an accurate reconstruction of the trade's lifecycle sequence.
There are three levels of function components in the CDM to define the processing of lifecycle events:

Primitive creation
Event creation
Workflow step creation
Each of those components can leverage any calculation or utility function already defined in the CDM. As part of the validation processe embedded in the CDM, an object validation step is included in all these object creation functions to ensure that they each construct valid CDM objects. Further details on the underlying calculation and validation processes are described in the calculation-process and validation-process."
"What is the process for novation, and what are the differences between partial novation and full novation?","a partial novation is described by combining a quantity change primitive event (describing the partial unwind of the transaction being novated away) and a contract formation primitive event (describing the new contract with the novation party).
 The event represents the partial novation of a contract, which comprises the following:

a split primitive
a quantity change primitive applied to each post-split trade, where the total quantity should match the quantity of the original trade and none of the quantities is 0. A quantity of 0 for the remaining trade would result in a termination and represent a full novation.
a party change primitive applied to the post-split trade whose quantity corresponds to the novated quantity.
""primitiveInstruction"" : {
     ""split"" : {
       ""breakdown"" : [ {
         ""partyChange"" : {
           ""counterparty"" : {
             ""partyReference"" : {
               ""value"" : {
                 ""name"" : {
                   ""value"" : ""Bank Z""
                 },
                 ""partyId"" : [ {
                   ""identifier"" : {
                     ""value"" : ""LEI3RPT0003""
                   },
                   ""identifierType"" : ""LEI"",
                 } ]
               }
             },
             ""role"" : ""PARTY_1""
           },
           ""tradeId"" : [ {
             ""assignedIdentifier"" : [ {
               ""identifier"" : {
                 ""value"" : ""LEI3RPT0003DDDD""
               },
               ""identifierType"" : ""UNIQUE_TRANSACTION_IDENTIFIER""
             } ],
             ""issuer"" : {
               ""value"" : ""LEI3RPT0003""
             },
           } ]
         },
         ""quantityChange"" : {
           ""change"" : [ {
             ""quantity"" : [ {
               ""value"" : {
                 ""amount"" : 5000,
                 ""unitOfAmount"" : {
                   ""currency"" : {
                     ""value"" : ""USD""
                   }
                 }
               }
             } ]
           } ],
           ""direction"" : ""REPLACE""
         }
       }, {
         ""quantityChange"" : {
           ""change"" : [ {
             ""quantity"" : [ {
               ""value"" : {
                 ""amount"" : 8000,
                 ""unitOfAmount"" : {
                   ""currency"" : {
                     ""value"" : ""USD""
                   }
                 }
               }
             } ]
           } ],
           ""direction"" : ""REPLACE""
         }
       } ]
     }
   }


A business event is atomic, i.e. its primitive components cannot happen independently. They either all happen together or not at all. In the above partial novation example, the existing trade between the original parties must be downsized at the same time as the trade with the new party is instantiated. Trade compression is another example, that involves multiple before trades being downsized or terminated and new trades being created between multiple parties, all of which must happen concurrently."
"How is collateral management represented, and what are the key processes involved?","Eligible Collateral Representation:

Within collateral documentation, it is common to detail what assets you will exchange with your counterparties, i.e., what you deem eligible collateral. Such information is found in bilateral legal documents, custodian triparty agreements and is also used for other purposes where defining whether an asset is eligible to be used as collateral to mitigate risk on a defined set (portfolio) of financial instruments between parties.

Data Requirements:

Data requirements to represent eligible collateral include common information such as asset descriptors, e.g., who issues the asset, the asset type, its maturity profile, any related agency credit risk rating, and if any collateral haircut is to be applied to the asset's value.

Challenges of Representation:

However, it is evident for each method chosen there is no common data standard to express the same information for all the data attributes used. ... Having no common standards in place to represent the key data has led to lengthy negotiation, misinterpretation, lack of interoperability and downstream operational inefficiency."
"What role does technology, such as distributed ledger or smart contracts, play in automating processes?","Accelerates financial technology innovation by providing a common, readily operational foundation for how technologies like distributed ledger, smart contracts, cloud computing, and artificial intelligence can be applied to financial markets."
How does the model manage regulatory requirements across different jurisdictions?,"Composable and normalised model representation of the ISDA agreements. The terms of an ISDA agreement can be defined by identification of the published base document, and the elections or amendments made to that base in a specific legal agreement. There are distinct versions of the published agreements for jurisdiction and year of publication, but the set of elections and amendments to those base agreements often belong to a common universe. Therefore, the CDM defines each of these terms in a single location, and allows for the representation of a specific legal agreement by combining terms where appropriate. The following legal agreements are supported in the CDM:

Initial Margin Agreements

ISDA 2016 Phase One Credit Support Annex (""CSA"") (Security Interest -- New York Law)
ISDA 2016 Phase One Credit Support Deed (""CSD"") (Security Interest -- English Law)
ISDA 2016 Phase One CSA (Loan -- Japanese Law)
ISDA 2016 ISDA-Clearstream Collateral Transfer Agreement (""CTA"") (New York law and Multi Regime English Law) and Security Agreement
ISDA 2016 ISDA-Euroclear CTA (New York law and Multi Regime English Law) and Security Agreement
ISDA 2018 CSA (Security Interest -- New York Law)
ISDA 2018 CSD (Security Interest -- English Law)
ISDA 2019 Bank Custodian CTA and Security Agreement (English Law, New York Law)
ISDA 2019 ISDA-Clearstream CTA and Security Agreement (Luxembourg Law -- Security-provider or Security-taker name)
ISDA 2019 ISDA-Euroclear CTA and Security Agreement
Variation Margin Agreements

ISDA 2016 CSA for Variation Margin (""VM"") (Security Interest - New York Law)
ISDA 2016 CSA for VM (Title Transfer -- English Law)
ISDA 2016 CSA for VM (Loan -- Japanese Law)
ISDA 2016 CSA for VM (Title Transfer -- Irish Law)
ISDA 2016 CSA for VM (Title Transfer -- French Law)
Master Agreement Schedule

ISDA 2002 Master Agreement Schedule (Partial agreement representation)
Composable and normalised model representation of the eligible collateral schedule for initial and variation margin into a directly machine readable format.

Linking of legal agreement into a trade object through the CDM referencing mechanism.

Mapping to ISDA Create derivative documentation negotiation platform : Synonyms identified as belonging to ISDA_Create_1_0 have been defined to establish mappings that support automated transformation of ISDA Create documents into objects that are compliant with the CDM.

The mapping between the two models through the use of Synonyms validated that all the necessary permutations of elections and data associated with the supported agreements have been replicated in the CDM
Ingestion of JSON sample files generated from ISDA Create for samples of executed documents has been implemented in the CDM Portal to demonstrate this capability between ISDA Create and the CDM.
More details on Synonyms are provided in the Mapping (Synonym) section of this document."
What are the benefits of using a common model for post-trade processing?,"It is important for implementors of the CDM to understand the scope of the model with regard to specifications and executable code for the above list of post-trade lifecycle processes.

The CDM process model leverages the function component of the Rosetta DSL. A function receives a set of input values and applies logical instructions to return an output. The input and output are both CDM objects (including basic types). While a function specifies its inputs and output, its logic may be fully defined or only partially defined depending on how much of the output's attribute values it builds. Unspecified parts of a process represent functionality that firms are expected to implement, either internally or through third-parties such as utilities.

It is not always possible or practical to fully specify the business logic of a process from a model. Parts of processes or sub-processes may be omitted from the CDM for the following reasons:

The sub-process is not needed to create a functional CDM output object.
The sub-process has already been defined and its implementation is widely adopted by the industry.
The sub-process is specific to a firm's internal process and therefore cannot be specified in an industry standard.
Given these reasons, the CDM process model focuses on the most critical data and processes required to create functional objects that satisfy the below criterion:

All of the qualifiable constituents (such as BusinessEvent and Product) of a function's output can be qualified, which means that they evaluate to True according to at least one of the applicable Qualification functions.
Lineage and cross-referencing between objects is accurate for data integrity purposes.
For any remaining data or processes, implementors can populate the remaining attribute values required for the output to be valid by extending the executable code generated by the process model or by creating their own functions.

For the trade lifecycle processes that are in scope, the CDM process model covers the following sub-process components, which are each detailed in the next sections:

Validation process
Calculation process
Event creation process"
How does the model handle reconciliation processes between trading parties?,"By applying CDM from trade negotiation downstream across the lifecycle, this eliminates the risk of mismatches and reconciliation breaks, creating a golden entry point where trade data is booked in standardised format prior to executing the opening leg of the SFT. Delivering standardisation pre-trade means less risk of downstream operational errors and it reduces the reconciliation burden."
What role does the model play in automating corporate actions and other lifecycle events?,"This attribute specifies the inputs required to perform the event's state transition and comprises a subset of the attributes of the business event itself. It is optional because it is only required for all pre-acceptance workflow steps. Once accepted, the business event is entirely represented, including its instructions, by the businessEvent attribute.

Validation components are in place to check that the businessEvent and proposedEvent attributes are mutually exclusive.

type EventInstruction:
  intent EventIntentEnum (0..1)
  corporateActionIntent CorporateActionTypeEnum (0..1)
  eventDate date (0..1)
  effectiveDate date (0..1)
  packageInformation IdentifiedList (0..1)
  instruction Instruction (0..*)"
"What are the key differences in handling various asset classes, such as equities, fixed income, and derivatives?","Modelling Approach
Scope
The model's primary intention is to deliver standards for OTC Derivatives with a focus on uncleared margin rules. In addition, the approach is intended to also be used to express collateral eligibility for other industry workflows such as Securities Lending, Repo and Exchange Traded Derivatives (ETD). The model foundations, broad range of attributes and functions has been constructed with this in mind and can be extended further to operate to wider processes.

The common data requirements have been established through industry working groups reviewing a wide range of examples in order to identify collateral for the purpose of constructing eligible collateral specifications, including representation of additional attributes for regulatory risk and credit factors. For the purpose of understanding the principle, these can be divided into the following categories:

Issuer Identification
Asset Identification
Collateral Haircuts
Maturity Ranges
Concentrations Limits
Treatments Functions
The data attributes within the model provides the flexibility to firstly identify the collateral issuer and asset class, then define its maturity if relevant, then apply treatment rules for any chosen haircut percentages, concentration limits and inclusion or exclusion conditions. The combination of these terms allows a wide range of collateral and associated data for eligibility to be represented.

Approach to identifying Collateral Assets
The universe of collateral used throughout the industry for risk mitigation purposes is vast and the intention is for the CDM to provide a standard means of identifying as much of this collateral universe as possible initially and then extend the model further as required via open-source contributions under the CDM governance structure.

At the outset, there have been no common standards for describing collateral; the foundational structure in the CDM provides a means to identify a majority of collateral issuers and covers a wide range of asset types that are commonly seen in eligible collateral data.

The approach in the CDM is to adopt a similar method to the 'Animal Kingdom' tree and taxonomy (kingdom → phylum → class → order→ family → genus → species) -- i.e., that there is one method for describing any of the core attributes of an ""animal"" (i.e., type of issuer/type of asset/type of economic terms) that need to be referenced, but only one way. Each issuer type, asset type, economic type etc has a unique place in the universe of collateral but is logically grouped together with similar types.

An illustrative example for understanding the principle is shown here:

image

The CDM method for representing eligible collateral will be capable of reference to, and inclusion in, common master and respective collateral documentation for OTC Derivatives and non- OTC master agreements (notably Repo and Securities Lending) and potentially for OTC Cleared and Exchange Traded Derivatives. For this reason, it is important that the CDM is able to accommodate Regulatory Uncleared Margin Rules concepts that are relevant but the model should not prescribed by them.

Although the industry will benefit from using a digital standard to describe collateral, there is also a need to recognise that market participants may want to identify eligible collateral without fully describing every feature and instead use industry identifiers, where available. Thus, the CDM also provides a means that collateral issuers can be identified using common legal entity identifiers such as an LEI. Similarly, asset types can be identified using a product ID such as ISIN or CUSIP or a standard taxonomy source.

High Level Design Principles
The foundational data structure from the highest level allows firstly to represent eligibility through specification of criteria:

image

The Asset type is used to specify criteria related to the nature of the asset, such as its type (cash, debt, equity, or other), its country of origin or its denominated currency.

The Issuer type is used to specify criteria related to the issuer of the asset, such the type of issuer (government, corporate, etc), specific issuer name, or agency rating

Treatment is used to specify the valuation percentage, any concentration limits and or specific inclusion or exclusion conditions, which additionally apply to filter whether a piece of collateral is eligible or not.

The combination of these terms allows a wide variety of eligible collateral types to be represented and a structure can be used to identify individual collateral types or a group of collateral assets for inclusion in specifying eligible collateral schedule details.
"
"What are the key steps involved in the clearing process, and how is it represented in the lifecycle of a trade?","The clearing process involves several key steps, represented in the lifecycle of a trade as follows:

Trade Execution: The trade is executed between two counterparties. This initial step generates the first trade state, which will undergo changes as part of the clearing process.

Trade Splitting: In many clearing scenarios, the trade is split into multiple parts. This is done using the split operator, which creates identical copies of the trade to be allocated or cleared separately. The split must happen before any other operations.

Clearing Instruction: After splitting, specific clearing instructions are applied to each portion of the trade. These instructions could involve changing the quantity or assigning the trades to different clearing parties or legal entities.

Contract Formation: Once the trade is cleared, a legally binding contract is formed between the clearing parties. This is done using the contract formation primitive, which associates the necessary legal agreements with the cleared trade state.

Validation and Compliance: The clearing process may include validation steps to ensure that the cleared trade complies with regulatory requirements and market rules.

Trade State Transition: Throughout the process, the trade state transitions are tracked using lineage. Each state transition is tied to the previous one, allowing full traceability of the trade's lifecycle.

In summary, the clearing process in the CDM involves splitting trades, applying clearing instructions, forming contracts, and ensuring compliance, all while maintaining traceability through state transitions in the trade's lifecycle."
"How does the allocation process work, and what factors determine how trades are allocated across different accounts?","The allocation process in the CDM (Common Domain Model) involves splitting an initial trade into smaller portions, which can then be allocated to different accounts or legal entities. This is achieved using a special case of the split operator, a primitive operator used for events like clearing and trade allocation.

Key aspects of the allocation process:

Trade Splitting: The split operator creates multiple identical copies of the original trade state. It does not modify the original trade state but generates multiple outputs, each representing a portion of the original trade.

Order of Operations: The split must be executed before other operations (such as applying specific instructions to the sub-trades). After the split, instructions like quantity changes and party changes are applied to each portion to allocate the trade to different accounts or legal entities.

Breakdown of Instructions: The allocation instruction includes a breakdown of how the trade should be divided, which is specified using primitive instructions like changing the quantity of each portion and assigning them to different parties. This allows for flexibility in how trades are split and distributed across accounts.

Contract Formation: After the allocation, contract formation may occur separately for each portion. This means that each sub-trade can have its own legal agreement associated with the new legal entities or accounts it has been assigned to. In some cases, contract formation is part of a later lifecycle event, such as novation.

Determining Allocation: Factors such as the trade quantity, legal entity assignments, and the specific terms of the trade or master agreement will influence how the trade is allocated. These are determined by the breakdown provided in the allocation instruction.

Lineage Tracking: The CDM tracks the lineage of each trade state. After a trade is allocated, the new sub-trades reference the original trade state they were derived from, ensuring that the lifecycle of each trade is traceable.

In summary, the allocation process involves using a split operator to divide an initial trade into smaller portions, applying instructions like quantity changes and party assignments to distribute the trades across different accounts. The process is flexible and can be tailored to specific scenarios, such as clearing or post-execution contract formation."
"How is novation processed, and what are the roles of the original and new counterparties?","Novation is a process in the trade lifecycle where one party to a trade is replaced by a new counterparty without altering the other terms of the trade. The key steps in novation and the roles of the original and new counterparties are as follows:

Trade Split: During novation, the original trade is split into multiple parts using the split operation. Each part represents a portion of the trade, and corresponding instructions such as quantity changes and party changes are applied.

Creation of a New Contract: One of the resulting trades becomes a new contract, with the original counterparty replaced by a new counterparty. The new counterparty takes on the obligations and rights of the original counterparty in the trade.

Closing the Original Trade: The original contract is marked as ClosedState, with the reason indicated as Novated. This means the original trade is no longer active, but its details are retained as part of the trade's lifecycle history.

Role Transition: In novation, the original counterparty is replaced by the new counterparty, who assumes the responsibilities of the former. The other party to the trade remains unchanged and continues fulfilling its contractual obligations.

Synchronous Execution: All operations related to novation, such as quantity adjustments and counterparty changes, must be executed simultaneously to ensure the integrity of the trade lifecycle.

In summary, novation replaces the original counterparty with a new one by splitting the trade and creating a new contract while preserving the other terms of the trade."
How does the model handle the reallocation of Positions after a novation event?,"After a novation event, the CDM (Common Domain Model) handles the reallocation of positions through several key mechanisms:

Trade Splitting:

In a novation scenario, the original trade is often split into multiple parts using the split operator. The original trade is divided into new trade states, each representing a portion of the original position. This allows the model to track the reallocation of positions to new counterparties.
Quantity Changes:

After the trade is split, the quantity change primitive is applied to each resulting trade. This ensures that the total quantity of the original trade is correctly allocated across the new positions. If it's a partial novation, one part of the trade is assigned to the new counterparty with a reduced quantity, while the remaining portion stays with the original counterparty. In the case of a full novation, the entire quantity is transferred to the new counterparty.
Party Changes:

The key feature of novation is the replacement of one counterparty with a new party. The party change primitive is applied to the newly allocated trade, updating the trade's counterparty details. This ensures that the new trade state reflects the change in participants, transferring the obligations from the original party to the new one. The model captures this through the BuyerSeller data type, which specifies the roles of the parties involved in the novated trade.
Closed State for Original Trade:

The original trade that is being novated is marked as closed in the model. The ClosedState attribute records that the original trade has been novated, ensuring that the lifecycle of the position is accurately tracked. This closure ensures that the original position is no longer active and has been replaced by the new novated positions.
Lineage and Trade State Tracking:

The model ensures that the lineage of each trade state is preserved. After a novation event, the model ties the newly created trade states (those allocated to the new counterparty) to the original trade state. This tracking ensures that the entire lifecycle of the trade, from its initial state through novation, is documented.
In summary, after a novation event, the CDM model reallocates positions by:

Splitting the original trade,
Applying quantity and party changes,
Marking the original trade as closed, and
Tracking the lifecycle of the trade states through lineage.
This process ensures accurate reallocation of positions and a clear audit trail of the novation event."
How does the system ensure that all parties are informed and updated during a novation event?,"During a novation event, the system ensures that all parties are informed and updated through a combination of structured data updates, event tracking, and communication mechanisms within the CDM (Common Domain Model). Here’s how it works:

Event Qualification and Tracking:

The event qualification functions in CDM categorize and qualify lifecycle events, such as novation. These functions apply business logic to ensure that the event is correctly identified and processed. The system tracks the transition of trade states from the original trade to the novated trade, ensuring that all steps are accurately recorded and traceable. This helps ensure transparency and clarity for all parties involved in the trade.
Trade State Updates:

The system ensures that the TradeState is updated to reflect the changes resulting from the novation event. This includes the creation of new trade states for the novated portions and the closure of the original trade. These updates are critical for ensuring that all parties have access to the most recent trade information, including the new counterparty and contract terms.
Party Change Information:

During a novation, one of the key elements is the transfer of rights and obligations from one party to another. The party change primitive updates the relevant trade records with the new counterparty information. This ensures that the new counterparty, as well as the original counterparties, are aware of the changes to the trade.
BuyerSeller Role Definition:

The BuyerSeller data type defines the direction of the transaction (i.e., who is buying and who is selling) after the novation. This ensures that all parties, including the new counterparty, are clearly informed about their roles and the flow of payments or deliveries related to the trade.
Notification through Business Events:

The novation event is considered a business event in the CDM model, which includes a set of primitive instructions to describe the transition. The system ensures that these events are atomic (they either all happen together or not at all), and each event triggers updates to all relevant parties. These updates may be communicated through internal systems, third-party platforms, or directly via API integrations to external parties.
Audit and Lineage:

The system maintains an audit trail of the novation event by preserving the lineage of the trade. This lineage links the new novated trades to the original trade, ensuring that all parties can trace the trade’s history and understand how the novation occurred. This clear tracking of trade states is essential for regulatory compliance and ensuring that all parties are aware of the trade's lifecycle.
Legal and Regulatory Compliance:

The system incorporates legal agreements and regulatory rules as part of the novation process. By referencing these agreements and ensuring compliance with rules such as uncleared margin requirements, the system makes sure that all parties are kept informed about any legal or regulatory obligations that arise from the novation.
In summary, the system ensures that all parties are informed and updated during a novation event by:

Qualifying and tracking the event through trade state updates,
Clearly updating party roles,
Notifying all relevant parties through business events,
Maintaining a clear audit trail via lineage, and
Ensuring compliance with legal and regulatory requirements.
These mechanisms provide transparency, accuracy, and accountability, keeping all participants in the loop during the novation process."
"What is the role of a central counterparty (CCP) in the clearing process, and how does it affect the trade's lifecycle?","Role of a Central Counterparty (CCP) in the Clearing Process:
Risk Mitigation and Collateral Management:

The CCP acts as an intermediary between counterparties, mitigating risk by stepping into the trade and becoming the buyer to every seller and the seller to every buyer. This process is crucial for reducing counterparty risk, especially in the case of OTC derivatives.
To protect against counterparty default, the CCP manages the exchange of collateral between parties. Collateral is exchanged under the terms specified in credit support documentation. These terms include variation margin (to cover the current replacement cost) and initial margin (to cover potential future losses before the default can be closed out).
Legal Agreements and Collateral Specifications:

The Master Agreement and additional credit support documentation are essential for defining the terms of collateral exchange between the parties involved in an OTC derivative. The terms and eligible collateral criteria are digitally represented using CDM's AgreementTerms and EligibleCollateralSpecification data types. The CCP ensures that both parties follow these terms, especially when margin requirements need to be met.
EligibleCollateralCriteria defines the criteria for the assets that can be posted as collateral, including the type of asset, the issuer, and specific treatment rules such as haircuts or concentration limits. The CCP enforces these rules to ensure the posted collateral meets the agreed-upon standards.
Trade Lifecycle Events:

A CCP plays a critical role in the trade’s lifecycle by clearing trades and ensuring they are executed and settled according to the predefined agreements. In a novation scenario, for example, the CCP may become the new counterparty, replacing the original parties. The lifecycle event would be recorded in CDM using the partyChange and quantityChange primitives, ensuring the trade state is updated to reflect the new counterparty.
The Create_Split and Create_QuantityChange functions may be applied when positions need to be split and reallocated between the CCP and the original counterparties. The trade’s lifecycle continues under the management of the CCP, which reduces the risk of default by holding and enforcing collateral requirements.
Collateral Posting and Reallocation:

The EligibleCollateralSpecification and CollateralTreatment data types specify the details of collateral management, including the rules for asset eligibility, issuer criteria, and concentration limits. The CCP ensures that all posted collateral aligns with these specifications, reducing the risk to the parties involved.
If a trade needs to be reallocated, such as during a novation or a settlement event, the CCP facilitates this by managing the collateral associated with the reallocated positions. The CollateralTreatment rules are applied to ensure that collateral is properly transferred, valued, and managed.
Settlement and Clearing:

Once a trade is cleared, the CCP manages the settlement process, ensuring that both parties fulfill their obligations. The settlement terms are outlined in the SettlementTerms data type, which defines whether the settlement is cash or physical, the settlement currency, and the relevant dates. The CCP facilitates this process by coordinating between the parties and ensuring that the correct amounts are transferred.
Transparency and Compliance:

By managing collateral, the CCP ensures that all parties adhere to the terms of the Master Agreement and credit support documentation. This includes enforcing compliance with initial margin and variation margin rules, ensuring that collateral is posted and managed according to the EligibleCollateralCriteria.
The CCP also plays a key role in providing transparency, as it centralizes the collateral and trade management process, reducing bilateral risks and enhancing trust in the financial system."
How are collateral requirements adjusted following a clearing or novation event?,"Following a clearing or novation event, collateral requirements are adjusted through a structured and standardized process that ensures the eligibility and valuation of collateral are updated according to the new trade or counterparty details. The Common Domain Model (CDM) facilitates this adjustment by employing several key mechanisms:

1. Reevaluation of Eligible Collateral:
After a novation or clearing event, the eligibility of collateral is reassessed based on the new counterparty's agreements and the terms of the transaction. The EligibleCollateralCriteria data type is used to define what assets are deemed eligible collateral, including the asset’s type, issuer, maturity, and any applicable haircuts or concentration limits. This ensures that the new counterparty's risk exposure is mitigated by acceptable collateral.
Any new collateral posted will have to meet the specific Issuer Criteria (e.g., issuer type, country of origin, rating) and Asset Criteria (e.g., asset type, maturity, currency) defined in the legal agreements.
2. Application of Haircuts and Concentration Limits:
When collateral requirements change, haircuts and concentration limits may be applied or adjusted to ensure the risk associated with the collateral is accurately reflected. The CollateralTreatment data type allows for applying valuation treatments (e.g., haircuts) and concentration limits (e.g., percentage or value limits) to the eligible collateral. For example:
A haircut percentage may be applied to account for fluctuations in the value of the collateral.
Concentration limits ensure that collateral from any one issuer or asset type does not exceed a certain threshold, reducing over-reliance on a single type of collateral.
3. Handling of Multiple Counterparties:
In a novation event, where one counterparty is replaced by another, the collateral requirements may be updated to reflect the new counterparty's credit profile or risk appetite. The CDM allows for specifying the counterparty role (Party1, Party2) and applying specific collateral rules to the new counterparty through the EligibleCollateralSpecification.
Issuer and Asset Criteria are applied to ensure the new counterparty’s collateral meets their specific requirements, such as rating thresholds or asset types.
4. Adjustment of Margin Requirements:
The novation or clearing event can trigger a recalculation of initial margin and variation margin. The CollateralValuationTreatment handles adjustments to margin percentages or additional haircuts for specific assets, ensuring that sufficient collateral is posted to cover the current and potential future exposure. The system can also account for FX-related haircuts or other regulatory requirements.
5. Inclusion and Exclusion Rules:
Collateral can be marked as included or excluded from eligibility based on updated legal agreements and new counterparty risk considerations. The isIncluded boolean attribute under the CollateralTreatment allows specific assets to be accepted or rejected based on their eligibility after the novation or clearing event. For example, a previously eligible asset might now be excluded due to the new counterparty’s preferences or regulatory restrictions.
6. Regulatory and Contractual Compliance:
Collateral adjustments following a novation or clearing event must comply with regulatory frameworks such as BCBS/IOSCO and Basel III. These frameworks define specific criteria for collateral eligibility, including concentration limits, haircuts, and issuer risk. The CDM ensures that these criteria are applied to meet regulatory standards for both cleared and uncleared OTC derivatives, as well as securities lending and repo transactions."
What is the common domain model?,"The Common Domain Model (CDM) is a standardised, machine-readable and machine-executable blueprint for how financial products are traded and managed across the transaction lifecycle."
What are the core benefits of the common domain model,"1, mutualised free open-source standardised digital blueprint on how to represent financial transactions, performance and business events. 2, Extensible to compose financial instruments by assembling reusable components. Already covers robustly derivative and securities financial transactions. 3, Scalable as event-driven model that encapsulates primitive components that will de facto make the fabric of complex  business and operational processes. 4, Operational and functional to codify the contract mechanics and business logic of legal agreements. 5, Unambiguous in digitising functionally complex business and regulatory logic  into code. 6, Directly approachable as published in both human readable and machine executable languages. 7, Implementable across several strategic uses cases in capital markets for better automation and greater consistency e.g. Trade management systems, clearing, digital documentation,  collateral managements, regulatory reporting."
What is the purpose of the common domain model,"A single, digital processing standard for trade events and actions enhances financial markets' operational efficiency in several ways:

Enables inter-operability and straight-through processing across firms, solutions and platforms, reducing the need for reconciliation caused by variations in how each firm records trade lifecycle events.
Accelerates financial technology innovation by providing a common, readily operational foundation for how technologies like distributed ledger, smart contracts, cloud computing, and artificial intelligence can be applied to financial markets.
Delivers better regulatory oversight, promotes transparency and alignment between regulators and market participants and enables consistency in regulatory reporting, by providing a standard representation of trade data and supporting machine executable reporting requirements."
What is the design priciple of the common domain model,"To support these objectives, the CDM is built according to a set of design principles that include the following concepts:

Normalisation through abstraction of common components
Composability where objects are composed and qualified from the bottom up
Mapping to existing industry messaging formats
Embedded logic to represent industry processes
Modularisation into logical layers"
What is the scope of the common domain model,"The CDM covers OTC derivatives, cash securities, securities financing, commodities, and can expand to include other Capital Markets products and Asset Classes."
What are the components of the common domain model,"The CDM is made of three sets of components:

The FINOS CDM Distribution 
The Rosetta DSL 
CDM Applications "
Please give me an explnantion of Product model of the common domain model,"Where applicable, the CDM follows the data structure of the Financial Products Markup Language (FpML), which is widely used in the OTC Derivatives market. For example, the CDM type PayerReceiver is equivalent to the FpML PayerReceiver.model. Both of these are data structures used frequently throughout each respective model. In other cases, the CDM data structure is more normalised, per Development Guidelines. For example, price and quantity are represented in a single type, TradableProduct, which is shared by all products. Another example is the use of a composable product model whereby:

Economic terms are specified by composition, For example, the InterestRatePayout type is a component used in the definition of any product with one or more interest rate legs (e.g. Interest Rate Swaps, Equity Swaps, and Credit Default Swaps).
Product qualification is inferred from those economic terms rather than explicitly naming the product type, whereas FpML qualifies the product explcitly through the product substitution group.
Regardless of whether the data structure is the same or different from FpML, the CDM includes defined Synonyms that map to FpML (and other models) and can be used for transformation purposes. More details on Synonyms are provided in the Mapping (Synonym) section of this document."
What is TradableProduct in product model of the common domain model,"A tradable product represents a financial product that is ready to be traded, meaning that there is an agreed financial product, price, quantity, and other details necessary to complete an execution of a security or a negotiated contract between two counterparties. Tradable products are represented by the TradableProduct type.                          The primary set of attributes represented in the TradableProduct data type are ones that are shared by all trades and transactions. For example, every trade has a price, a quantity (treated jointly as a trade lot), and a pair of counterparties. In some cases, there are ancillary parties, or an allowable adjustment to the notional quantity. All of the other attributes required to describe a product are defined in distinct product data types."
What is Counterparty in product model of the common domain model,"The counterparty attribute of a TradableProduct is constrained to be exactly of cardinality 2. The CDM enforces that a transaction can only occur between a pair of counterparties, with any other party involved in the transaction represented by the ancillaryParty attribute.

The counterparty attribute uses the Counterparty data type, which links a specific Party object identifying that party to its role in the transaction. The counterparty roles in the CDM are normalised to be either Party1 or Party2 and captured as a pair of enumerated values.

This design allows to use anonymised Party1 and Party2 values to specify the direction of flows in the definition of a tradable product without having to reference specific parties. This means that the same product can now be defined in a party-agnostic way and used to represent transactions between potentially many different parties."
What is TradeLot in product model of the common domain model,"A trade lot represents the quantity and price at which a product is being traded.

In certain markets, trading the same product with the same economics (except for price and quantity) and the same counterparty may be treated as a separate trade. Each trade is represented by a tradable product containing only 1 trade lot. In other markets, trading the same product with the same characteristics (except for price and quantity) is represented as part of the same trade. In this case, a single tradable product contains multiple trade lots represented as an array of the TradeLot data type.

When a trade can have multiple trade lots, increases (or upsize) and decreases (or unwind) are treated differently. An increase adds a new TradeLot instance to the tradadable product, whereas a decrease reduces the quantity of one or more of the existing trade lots."
What is PriceQuantity in product model of the common domain model,"The price and quantity attributes of a trade, or of a leg of a trade in the case of composite products, are part of a data type called PriceQuantity. This data type also contains (optionally):

an observable, which describes the asset or reference index to which the price and quantity are related
settlement terms and the buyer/seller direction, in case that price and quantity are meant to be settled
a date, which indicates when these price and quantity become effective                                                                                                                                                              The price, quantity and observable attributes are joined together in a single PriceQuantity data type because in some cases, those 3 attributes need to be considered together. For example, the return leg of an Equity Swap will have:

the identifier for the shares as observable
the number of shares as quantity
the initial share price as price
However, those attributes are optional because in other cases, only some of them will be specified. In the fixed leg of an Interest Rate Swap, there is no observable as the rate is already fixed. An option trade will contain an instance of a PriceQuantity containing only the premium as price attribute, but no quantity or observable (the quantity and/or observable for the option underlyer will be specified in a different PriceQuantity instance).

Both the price and quantity can be specified as arrays in a single PriceQuantity. All elements in the array express the same values but according to different conventions. For example, the return leg of an Equity Swap may specify both the number of shares and the notional (a currency amount equal to: number of shares x price per share) as quantities. In a Forward FX trade, the spot rate, forward points and forward rate (equal to spot rate + forward points) may all be specified as prices. When mutiple values are specified for either the price or quantity attributes in a single PriceQuantity instance, they will be tied by rules that enforce that they are internally consistent.

The effective date attribute is optional and will usually be specified when a single trade has multiple trade lots, to indicate when each trade lot become effective (usually on or around the date when the lot was traded). The trade itself will have an effective date, corresponding to the date when the first lot was traded and the trade opened.

The price and quantity attributes in the PriceQuantity data type each have a metadata location which can reference a metadata address in one of the Payout data types. The metadata address-location pair allows for a reference to link objects without populating the address object in persistence. This capability helps to support an agnostic definition of the product in a trade (i.e. a product definition without a price and quantity). However, the reference can be used to populate values for an input into a function or for other purposes."
What is SettlementTerms in product model of the common domain model,"In both the Equity Swap and Interest Rate Swap trade cases mentioned above, there are no settlement terms attached to the price and quantity. Instead, any future settlement is driven by the product mechanics and the price and quantity are just parameters in the definition of that product.

In other cases, it is necessary to define settlement terms when either the price or quantity or both are to be settled. A non-exhaustive list of cases includes:

A cash transaction, i.e. when buying a certain quantity of a security or commodity for a certain price
An FX spot of forward transaction
An option for which a premium must be paid
A swap transaction that involves an upfront payment, e.g. in case of unwind or novation
In those cases, the corresponding PriceQuantity object also contains settlementTerms and buyerSeller attributes to define that settlement. The actual settlement amounts will use the price and quantity agreed as part of the tradable product.

The SettlementTerms data type defines the basic characteristics of a settlement: the settlement date, currency, whether it will be cash or physical, and the type of transfer. For instance, a settlement could be a delivery-versus-payment scenario for a cash security transaction or a payment-versus-payment scenario for an FX spot or forward transaction. Those parameters that are common across all settlement methods are captured by the SettlementBase data type.

Cash and physical settlement methods require different, specific parameters which are captured by the additional cashSettlementTerms and physicalSettlementTerms attributes, respectively. For instance, a non-deliverable FX forward will use the cashSettlementTerms attribute to represent the parameters of the non-deliverable settlement, such as the observable FX fixing to use."
What is BuyerSeller in product model of the common domain model,"When a settlement occurs for the price and/or quantity, it is necessary to define the direction of that settlement by specifying which party pays what. That direction is captured by the BuyerSeller data type, that uses the normalised CounterpartyRoleEnum enumeration to specify who is the buyer and seller, respectively.                                  By convention, the direction of the settlement flows will be inferred as follows:

the buyer receives the quantity / pays the price, and
the seller receives the price / pays the quantity.
For instance in an FX spot or forward transaction, the respective units of the quantity and price will determine who is paying or receiving each currency."
What is Financial Product in product model of the common domain model,"A financial product is an instrument that is used to transfer financial risk between two parties. Financial products are represented in the Product type, which is also constrained by a one-of condition, meaning that for a single Tradable Product, there can only be one Product.                                                                                                  The CDM allows any one of these products to included in a trade or used as an underlier for another product (see the Underlier section). One unlikely case for a direct trade is Index, which is primarily used as an underlier.

Among this set of products, the contractual product is the most complicated and requires the largest data structure. In a contractual product, an exchange of financial risk is materialised by a unique bilateral contract that specifies the financial obligations of each party. The terms of the contract are specified at trade inception and apply throughout the life of the contract (which can last for decades for certain long-dated products), unless amended by mutual agreement. Contractual products are fungible (in other words, replaceable by other identical or similar contracts) only under specific terms: e.g. the existence of a close-out netting agreement between the parties.

Given that each contractual product transaction is unique, all of the contract terms must be specified and stored in an easily accessible transaction lifecycle model so that each party can evaluate the financial and counterparty risks during the life of the agreement.

Foreign Exchange (FX) spot and forward trades (including Non-Deliverable Forwards) and private loans also represent an exchange of financial risk represented by a form of bilateral agreements. FX forwards and private loans can have an extended term, and are generally not fungible. However, these products share few other commonalities with contractual products such as Interest Rate Swaps. Therefore, they are defined separately.

By contrast, in the case of the execution of a security (e.g. a listed equity), the exchange of finanical risk is a one-time event that takes place on the settlement date, which is usually within a few business days of the agreement. The other significant distinction is that securities are fungible instruments for which the terms and security identifiers are publically available. Therefore, the terms of the security do not have to be stored in a transaction lifecycle model, but can be referenced with public identifiers.

An Index product is an exception because it's not directly tradable, but is included here because it can be referenced as an underlier for a tradable product and can be identified by a public identifier."
What is Contractual Product in product model of the common domain model,"The scope of contractual products in the current model are summarized below:

Interest rate derivatives:
Interest Rate Swaps (incl. cross-currency swaps, non-deliverable swaps, basis swaps, swaps with non-regular periods, ...)
Swaptions
Caps/floors
FRAs
OTC Options on Bonds
Credit derivatives:
Credit Default Swaps (incl. baskets, tranche, swaps with mortgage and loans underlyers, ...)
Options on Credit Default Swaps
Equity derivatives:
Equity Swaps (single name)
Options:
Any other OTC Options (incl. FX Options)
Securities Lending:
Single underlyer, cash collateralised, open/term security loan
Repurchase Agreements:
Open Term, Fixed Term, Fixed Rate, Floating Rate
In the CDM, contractual products are represented by the ContractualProduct type. Note that price, quantity and counterparties are defined in TradableProduct as these are attributes common to all products. The remaining economic terms of the contractual product are defined in EconomicTerms which is an encapsulated type in ContractualProduct ."
What is Economic Terms in product model of the common domain model,"The CDM specifies the various sets of possible remaining economic terms using the EconomicTerms type. This type includes contractual provisions that are not specific to the type of payout, but do impact the value of the contract, such as effective date, termination date, date adjustments, and early termination provisions. A valid population of this type is constrained by a set of conditions which are not shown here in the interests of brevity."
What is Payout in product model of the common domain model,"The Payout type defines the composable payout types, each of which describes a set of terms and conditions for the financial responsibilities between the contractual parties. Payout types can be combined to compose a product. For example, an Equity Swap can be composed by combining an InterestRatePayout and an PerformancePayout.
A number of payout types extend a common data type called PayoutBase. This data type provides a common structure for attributes such as quantity, price, settlement terms and the payer/receiver direction which are expected to be common across many payouts.

The list of payouts that extend PayoutBase are:

InterestRatePayout
CreditDefaultPayout
OptionPayout
CommodityPayout
ForwardPayout
FixedPricePayout
SecurityPayout
Cashflow
PerformancePayout
AssetPayout
the ProtectionTerms data type encapsulated in CreditDefaultPayout
The price and quantity attributes in the PayoutBase structure are positioned in the ResolvablePriceQuantity data type. This data type mirrors the PriceQuantity data type and contains both the price and quantity schedules.

In addition that data type supports the definition of additional information such as a quantity reference, a quantity multiplier or the indication that the quantity is resettable. Those are used to describe the quantity of a payout leg that may need to be calculated based on other inputs: e.g. an exchange rate for the foreign leg in a Cross-Currency Swap or a share price for the funding leg of an Equity Swap.
By design, the CDM requires that each payout leg can only be associated with a single quantity schedule that defines this leg's contractual behaviour (e.g. for the payment of cashflows). In the PriceQuantity object, where that attribute is of multiple cardinality, other quantities may be provided ""for information only"" which can be inferred from the main quantity used in the payout leg: e.g. when a commodity quantity is associated to a frequency and needs to be multiplied by the period to get the total quantity.

Both the quantitySchedule and priceSchedule attributes have a metadata address that point respectively to the quantity and price attributes in the PriceQuantity data type. This special cross-referencing annotation in the Rosetta DSL allows to parameterise an attribute whose value may be variable by associating it to an address. The attribute value does not need to be populated in the persisted object and can be provided by another object, using the address as a reference.
"
What is Reusable in product model of the common domain model,"There are a number of components that are reusable across several payout types. For example, the CalculationPeriodDates class describes the inputs for the underlying schedule of a stream of payments."
What is Underlier in product model of the common domain model,"The underlier attribute on types OptionPayout, ForwardPayout and EquityPayout allows for any product to be used as the underlier for a corresponding products option, forward, and equity swap.
This nesting of the product component is another example of a composable product model. One use case is an interest rate swaption for which the high-level product uses the OptionPayout type and underlier is an Interest Rate Swap composed of two InterestRatePayout types. Similiarly, the product underlying an Equity Swap composed of an InterestRatePayout and an EquityPayout would be a non-contractual product: an equity security."
What is Data Templates in product model of the common domain model,"The ContractualProduct type is specified with the [metadata template] annotation indicating that it is eligible to be used as a template.

Financial markets often trade a high volume of trades with near identical contractual product data. Templates provide a way to store this data more efficiently. The contractual product data which is duplicated on each contract can be extracted into a single template and replaced by a reference. This allows each trade to specify only the unique contractual product data. The template reference can be resolved to a template object which can then be merged in to form a single, complete object.

For instance, Equity Swaps used by Equity Financing desks sometimes refer to a Master Confirmation agreement, which is an overall agreement that specifies all the standard Equity Swap terms that do not need to be renegotiated on each trade. Each contractual product would only specify the unique product details (such as start and end date, underlier, price and spread) together with a reference to the Master Confirmation containing the template product details.

Code libraries, written in Java and distributed with the CDM, contain tools to merge CDM objects together. Implementors may extend these merging tools to change the merging strategy to suit their requirements. The CDM Java Examples download, available via the CDM Portal Downloads page, contains a example demonstrating usage of a data template and the merging tools. See com.regnosys.cdm.example.template.TemplateExample."
What is Products with Identifiers in product model of the common domain model,"The abstract data type ProductBase serves as a base for all products that have an identifier, as illustrated below:

type ProductBase:
  productTaxonomy ProductTaxonomy (0..*)
  productIdentifier ProductIdentifier (0..*)

The data types that extend from ProductBase are Index, Commodity, Loan, and Security. Index and Commodity do not have any additional attributes. In the case of Commodity, the applicable product identifiers are the ISDA definitions for reference benchmarks. Loan and Security both have a set of additional attributes, as shown below:

type Loan extends ProductBase:
  borrower LegalEntity (0..*)
  lien string (0..1)
    [metadata scheme]
  facilityType string (0..1)
    [metadata scheme]
  creditAgreementDate date (0..1)
  tranche string (0..1)
    [metadata scheme]

type Security extends ProductBase:
  securityType SecurityTypeEnum (1..1)
  debtType DebtType (0..1)
  equityType EquityTypeEnum (0..1)
  fundType FundProductTypeEnum (0..1)
  economicTerms EconomicTerms (0..1)

condition DebtSubType:
  if securityType <> SecurityTypeEnum -> Debt
  then debtType is absent

condition EquitySubType:
  if securityType <> SecurityTypeEnum -> Equity
  then equityType is absent

condition FundSubType:
  if securityType <> SecurityTypeEnum -> Fund
  then fundType is absent

The product identifier will uniquely identify the security. The securityType is required for specific purposes in the model, for example for validation as a valid reference obligation for a Credit Default Swap. The additional security details are optional as these could be determined from a reference database using the product identifier as a key"
What is Product Qualification in product model of the common domain model,"Product qualification is inferred from the economic terms of the product instead of explicitly naming the product type. The CDM uses a set of Product Qualification functions to achieve this purpose. These functions are identified with a [qualification Product] annotation.

A Product Qualification function applies a taxonomy-specific business logic to identify if the product attribute values, as represented by the product's economic terms, match the specified criteria for the product named in that taxonomy. For example, if a certain set of attributes are populated and others are absent, then that specific product type is inferred. The Product Qualification function name in the CDM begins with the word Qualify followed by an underscore _ and then the product type from the applicable taxonomy (also separated by underscores).

The CDM implements the ISDA Product Taxonomy v2.0 to qualify contractual products, foreign exchange, and repurchase agreements. Given the prevalence of usage of the ISDA Product Taxonomy v1.0, the equivalent name from that taxonomy is also systematically indicated in the CDM, using a synonym annotation displayed under the function output. An example is provided below for the qualification of a Zero-Coupon Fixed-Float Inflation Swap:

func Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon:
  [qualification Product]
  inputs: economicTerms EconomicTerms (1..1)
  output: is_product boolean (1..1)
    [synonym ISDA_Taxonomy_v2 value ""InterestRate_IRSwap_Inflation""]
  set is_product:
    Qualify_BaseProduct_Inflation(economicTerms) = True
    and Qualify_BaseProduct_CrossCurrency( economicTerms ) = False
    and Qualify_SubProduct_FixedFloat(economicTerms) = True
    and Qualify_Transaction_ZeroCoupon(economicTerms) = True

If all the statements above are true, then the function evaluates to True, and the product is determined to be qualified as the product type referenced by the function name.

Note: In a typical CDM model implementation, the full set of Product Qualification functions would be invoked against each instance of the product in order to determine the inferred product type. Given the product model composability, a single product instance may be qualified as more than one type: for example in an Interest Rate Swaption, both the Option and the underlying Interest Rate Swap would be qualified.

The CDM supports Product Qualification functions for Credit Derivatives, Interest Rate Derivatives, Equity Derivatives, Foreign Exchange, and Repurchase Agreements. The full scope for Interest Rate Products has been represented down to the full level of detail in the taxonomy. This is shown in the example above, where the ZeroCoupon qualifying suffix is part of the function name. Credit Default products are qualified, but not down to the full level of detail. The ISDA Product Taxonomy v2.0 references the FpML transaction type field instead of just the product features, whose possible values are not publicly available and hence not positioned as a CDM enumeration.

The output of the qualification function is used to populate the productQualifier attribute of the ProductTaxonomy object, which is created when a ContractualProduct object is created. The product taxonomy includes both the product qualification generated by the CDM and any additional product taxonomy information which may come from the originating document, such as FpML. In this case, taxonomy schemes may be associated to such product taxonomy information, which are also propagated in the ProductTaxonomy object.

Many different financial taxonomies may be used by various segments of the financial industry to describe the same product. To support a multitude of taxonomies without adding any specific identity to data types in the model, a Taxonomy type is used to identify the source and attributes any particular taxonomy structure.

type Taxonomy:
   source TaxonomySourceEnum (0..1)
   value TaxonomyValue (0..1)

TaxonomyValue has been expanded to represent a complex type:

type TaxonomyValue: 

   name string (0..1)
       [metadata scheme]
   classification TaxonomyClassification (0..*)

   condition ValueExists:
       name exists or classification exists

TaxonomyClassification is also a complex type that support a hierarchical structure of any depth:

type TaxonomyClassification:
    className string (0..1)
    value string (1..1)
    description string (0..1)
    ordinal int (0..1)

The ProductTaxonomy data structure and an instance of a CDM object (serialised into JSON) are shown below:

type ProductTaxonomy extends Taxonomy:
    primaryAssetClass AssetClassEnum (0..1)
        [metadata scheme]
    secondaryAssetClass AssetClassEnum (0..*)
        [metadata scheme]
    productQualifier string (0..1)

    condition TaxonomyType:
        required choice source, primaryAssetClass, secondaryAssetClass

    condition TaxonomySource:
        if source exists then ( value exists or productQualifier exists )

    condition TaxonomyValue:
        optional choice value, productQualifier

""productTaxonomy"": [
  {
    ""primaryAssetClass"": {
      ""meta"": {
        ""scheme"": ""http://www.fpml.org/coding-scheme/asset-class-simple""
      },
      ""value"": ""INTEREST_RATE""
    },
  },
  {
    ""taxonomyValue"": {
      ""meta"": {
        ""scheme"": ""http://www.fpml.org/coding-scheme/product-taxonomy""
      },
      ""value"": ""InterestRate:IRSwap:FixedFloat""
    }
    ""taxonomySource"": ""ISDA""
  },
  {
    ""productQualifier"": ""InterestRate_IRSwap_FixedFloat"",
    ""taxonomySource"": ""ISDA""
  }
]"
What is Event Qualification in event model of the common domain model,"The CDM qualifies lifecycle events as a function of their primitive components rather than explicitly declaring the event type. The CDM uses the same approach for event qualification as for product qualification and is based on a set of Event Qualification functions. These functions are identified with a [qualification BusinessEvent] annotatation.

Event Qualification functions apply a taxonomy-specific business logic to identify if the state-transition attributes values, which are embedded in the primitive event components, match the specified criteria for the event named in that taxonomy. Like Product Qualification functions, the Event Qualification function name is prefixed with the word Qualify_ followed by the taxonomy name.

The CDM uses the ISDA taxonomy V2.0 leaf level to qualify the event. 23 lifecycle events have currently been qualified as part of the CDM.

One distinction with the product approach is that the intent qualification is also deemed necessary to complement the primitive event information in certain cases. To this effect, the Event Qualification function allows to specify that when present, the intent must have a specified value, as illustrated by the below example.

func Qualify_Termination:
  [qualification BusinessEvent]
  inputs:
    businessEvent BusinessEvent (1..1)
  output: is_event boolean (1..1)
  alias primitiveInstruction: businessEvent -> instruction -> primitiveInstruction only-element
  alias transfer: TransfersForDate( businessEvent -> after -> transferHistory -> transfer, businessEvent -> eventDate ) only-element

  set is_event:
    businessEvent -> intent is absent
      and (primitiveInstruction -> quantityChange only exists
          or (primitiveInstruction -> quantityChange, primitiveInstruction -> transfer) only exists)
      and (QuantityDecreasedToZero(businessEvent -> instruction -> before, businessEvent -> after) = True)
      and (businessEvent -> after -> state -> closedState -> state all = ClosedStateEnum -> Terminated)


If all the statements above are true, then the function evaluates to True. In this case, the event is determined to be qualified as the event type referenced by the function name.

The output of the qualification function is used to populate the eventQualifier attribute of the BusinessEvent object, similar to how product qualification works. An implementation of the CDM would call all of the Event Qualification functions following the creation of each event and then insert the appropriate value or provide an exception message.
"
What is Intent in event model of the common domain model,"The intent attribute is an enumeration value that represents the intent of a particular business event. It is used in the event qualifcation logic in cases where the primitive composition is not sufficient to uniquely infer a lifecycle event.

The description of each possible enumeration value provides an illustration of how this attribute is used.

enum EventIntentEnum:
   Allocation
   CashFlow
   Clearing
   Compression
   ContractFormation
   ContractTermsAmendment
   CorporateActionAdjustment
   CreditEvent
   Decrease
   EarlyTerminationProvision
   Increase
   IndexTransition
   NotionalReset
   NotionalStep
   Novation
   ObservationRecord
   OptionExercise
   OptionalExtension
   OptionalCancellation
   PortfolioRebalancing
   PrincipalExchange
   Reallocation
   Repurchase"
What is Workflow in event model of the common domain model,"The CDM provides support for implementors to develop workflows to process transaction lifecycle events.

A workflow represents a set of actions or steps that are required to trigger a business event, including the initial execution or contract formation. A workflow is organised into a sequence in which each step is represented by a workflow step. A workflow may involve multiple parties in addition to the parties to the transaction, and may include automated and manual steps. A workflow may involve only one step.

The CDM supports a workflow's audit trail by providing lineage from one step to another in that workflow.

type WorkflowStep:
  [metadata key]
  [rootType]
  businessEvent BusinessEvent (0..1)
  counterpartyPositionBusinessEvent CounterpartyPositionBusinessEvent (0..1)
  proposedEvent EventInstruction (0..1)
  rejected boolean (0..1)
  approval WorkflowStepApproval (0..*)
  previousWorkflowStep WorkflowStep (0..1)
    [metadata reference]
  nextEvent EventInstruction (0..1)
  messageInformation MessageInformation (0..1)
  timestamp EventTimestamp (1..*)
  eventIdentifier Identifier (1..*)
  action ActionEnum (0..1)
  party Party (0..*)
  account Account (0..*)
  lineage Lineage (0..1)
    [deprecated]
  creditLimitInformation CreditLimitInformation (0..1)
  workflowState WorkflowState (0..1)"
What is Workflow Step Business Event in event model of the common domain model,"This attribute specifies the business event that the workflow step is meant to generate. It is optional because the workflow may require a number of interim steps before the state-transition embedded within the business event becomes effective, therefore the business event does not exist yet in those steps. The business event attribute is typically associated with the final step in the workflow."
What is Proposed Event in event model of the common domain model,"This attribute specifies the inputs required to perform the event's state transition and comprises a subset of the attributes of the business event itself. It is optional because it is only required for all pre-acceptance workflow steps. Once accepted, the business event is entirely represented, including its instructions, by the businessEvent attribute.

Validation components are in place to check that the businessEvent and proposedEvent attributes are mutually exclusive.

type EventInstruction:
  intent EventIntentEnum (0..1)
  corporateActionIntent CorporateActionTypeEnum (0..1)
  eventDate date (0..1)
  effectiveDate date (0..1)
  packageInformation IdentifiedList (0..1)
  instruction Instruction (0..*)"
What is Next Event in event model of the common domain model,"Parties sometimes pre-agree a follow-on event that is meant to be executed after the current event completes, but separately from it. A typical scenario is an execution that specifies that the trade is intended for clearing at a pre-specified clearing house. In this case, the parameters of the next event are known in advance need to be agreed between the parties as part of the current event.

The parameters of this next event are represented by an EventInstruction data type included in the workflow process."
What is Previous Workflow Step in event model of the common domain model,"This attribute, which is provided as a reference, defines the lineage between steps in a workflow. The result is an audit trail for a business event, which can trace the various steps leading to the business event that was triggered."
What is Action in event model of the common domain model,"The action enumeration qualification specifies whether the event is a new one or a correction or cancellation of a prior one, which are trade entry references and not reflective of negotiated changes to a contract."
Please explain The Use of Agreements in Financial Markets,"Financial transactions consist primarily of agreements between parties to make future payments or deliveries to each other. To ensure performance, those agreements typically take the form of legally enforceable contracts, which the parties record in writing to minimize potential future disagreements.

It is common practice in some markets for different aspects of these agreements to be recorded in different documents, most commonly dividing those terms that exist at the trading relationship level (e.g. credit risk monitoring and collateral) from those at the transaction level (the economic and risk terms of individual transactions). Relationship agreements and individual transaction level documents are often called ""master agreements"" and ""confirmations"" respectively, and multiple confirmations may be linked to a single master agreement.

Both the relationship and transaction level documents may be further divided into those parts that are standard for the relevant market, which may exist in a pre-defined base form published by a trade association or similar body, and those that are more bespoke and agreed by the specific parties. The standard published forms may anticipate that the parties will choose from pre-defined elections in a published form, or create their own bespoke amendments.

The ISDA Master Agreement is an internationally recognised document which is used to provide certain legal and credit protection for parties who enter into OTC derivatives. Parties that execute agreements for OTC derivatives are expected to have bi-lateral Master Agreements with each other that cover an agreed range of transactions. Accordingly in the CDM each transaction can be associated with a single master agreement, and a single master agreement can be associated with multiple transactions.

In addition to the Master Agreement are sets of credit support documentation which parties may enter into as part of Master Agreement to contain the terms on which they will exchange collateral for their OTC derivatives. Collateral provides protection to a party against the risk that its counterparty defaults and fails to pay the amount that it owes on default. The risk of loss in this scenario is for the current cost of replacing the defaulted transactions (for which margin is called ""variation margin"") and the risk of further loss before the default can be closed out (called ""initial margin"" or ""independent amount"").

There are several different types of ISDA credit support document, reflecting variation and initial margin, regulatory requirements and terms for legal relationships under different legal jurisdictions. The key components of the suite of credit support documents are summarized below:

Credit Support Annexes (CSAs) exist in New York, English, Irish, French, and Japanese law forms. They define the terms for the provision of collateral by the parties in derivatives transactions, and in some cases they are specialized for initial margin or variation margin.
Credit Support Deed CSD (CSD) is very similar to a CSA, except that it is used to create specific types of legal rights over the collateral under English and Irish law, which requires a specific type of legal agreement (a deed).
The Collateral Transfer Agreement and Security Agreement (CTA and SA) together define a collateral arrangement where initial margin is posted to a custodian account for use in complying with initial margin requirements. The CTA/SA offers additional flexibility by allowing parties to apply one governing law to the mechanical aspects of the collateral relationship (the CTA) and a different governing law to the grant and enforcement of security over the custodian account (the SA).
In the CDM and in this user documentation, legal agreement refers to the written terms of a relationship-level agreement, and contract refers to the written terms defining an executed financial transaction.
"
Please explain Legal Agreements in the CDM,"The CDM provides a digital representation of the legal agreements that govern transactions and workflows. The benefits of this digital representation are summarized below:

Supporting marketplace initiatives to streamline and standardise legal agreements with a comprehensive digital representation of such agreements.
Providing a comprehensive representation of the financial workflows by complementing the trade and lifecycle event model and formally tying legal data to the business outcome and performance of legal clauses. (e.g. in collateral management where lifecycle processes require reference to parameters found in the associated legal agreements, such as the Credit Support Annex).
Supporting the direct implementation of functional processes by providing a normalised representation of legal agreements as structured data, as opposed to the unstructured data contained of a full legal text that needs to be interpreted first before any implementation (e.g. for a calculation of an amount specified in a legal definition).
The scope of the CDM legal agreement model includes all of the types of ISDA credit support documents. The legal agreement model is explained below, including examples and references to these types of documents.

The topics covered in this section are listed below:

Modelling Approach
Legal Agreement Data Structure
Linking Legal Agreements to contracts"
What is scope of legal agreements of common domain model,"The legal agreement model in the CDM comprises the following features:

Composable and normalised model representation of the ISDA agreements. The terms of an ISDA agreement can be defined by identification of the published base document, and the elections or amendments made to that base in a specific legal agreement. There are distinct versions of the published agreements for jurisdiction and year of publication, but the set of elections and amendments to those base agreements often belong to a common universe. Therefore, the CDM defines each of these terms in a single location, and allows for the representation of a specific legal agreement by combining terms where appropriate. The following legal agreements are supported in the CDM:

Initial Margin Agreements

ISDA 2016 Phase One Credit Support Annex (""CSA"") (Security Interest -- New York Law)
ISDA 2016 Phase One Credit Support Deed (""CSD"") (Security Interest -- English Law)
ISDA 2016 Phase One CSA (Loan -- Japanese Law)
ISDA 2016 ISDA-Clearstream Collateral Transfer Agreement (""CTA"") (New York law and Multi Regime English Law) and Security Agreement
ISDA 2016 ISDA-Euroclear CTA (New York law and Multi Regime English Law) and Security Agreement
ISDA 2018 CSA (Security Interest -- New York Law)
ISDA 2018 CSD (Security Interest -- English Law)
ISDA 2019 Bank Custodian CTA and Security Agreement (English Law, New York Law)
ISDA 2019 ISDA-Clearstream CTA and Security Agreement (Luxembourg Law -- Security-provider or Security-taker name)
ISDA 2019 ISDA-Euroclear CTA and Security Agreement
Variation Margin Agreements

ISDA 2016 CSA for Variation Margin (""VM"") (Security Interest - New York Law)
ISDA 2016 CSA for VM (Title Transfer -- English Law)
ISDA 2016 CSA for VM (Loan -- Japanese Law)
ISDA 2016 CSA for VM (Title Transfer -- Irish Law)
ISDA 2016 CSA for VM (Title Transfer -- French Law)
Master Agreement Schedule

ISDA 2002 Master Agreement Schedule (Partial agreement representation)
Composable and normalised model representation of the eligible collateral schedule for initial and variation margin into a directly machine readable format.

Linking of legal agreement into a trade object through the CDM referencing mechanism.

Mapping to ISDA Create derivative documentation negotiation platform : Synonyms identified as belonging to ISDA_Create_1_0 have been defined to establish mappings that support automated transformation of ISDA Create documents into objects that are compliant with the CDM.

The mapping between the two models through the use of Synonyms validated that all the necessary permutations of elections and data associated with the supported agreements have been replicated in the CDM
Ingestion of JSON sample files generated from ISDA Create for samples of executed documents has been implemented in the CDM Portal to demonstrate this capability between ISDA Create and the CDM.
More details on Synonyms are provided in the Mapping (Synonym) section of this document."
What is Design Principles of legal agreements of common domain model,"The key modelling principles that have been adopted to represent legal agreements are described below:

Distinction between the agreement identification features and the agreement content features
The agreement identification features: agreement name, publisher (of the base agreement being used), identification, etc. are represented by the LegalAgreementBase type.
The agreement content features: elections and amendments to the published agreement, related agreements and umbrella agreement terms are represented by the AgreementTerms.
Composite and extendable model.
The Legal Agreement model follows the CDM design principles of composability and reusability to develop an extendable model that can support multiple document types.
For instance, the LegalAgreementBase data type uses components that are also used as part of the CDM trade and lifecycle event components: e.g. Party, Identifier, date.
Normalisation of the data representation
Strong data type attributes such as numbers, Boolean, or enumerations are used where possible to create a series of normalised elections within terms used in ISDA documentation and create a data representation of the legal agreement that is machine readable and executable. This approach allows CDM users to define normalised elections into a corresponding legal agreement template to support functional processes.
In practice the use of elections expressed in a string format has been restricted, as the string format is generally unsuitable for the support of standardised functional processes.
The components of the legal agreement model specified in the CDM are detailed in the section below."
What is Agreement Identification of legal agreements of common domain model,"The CDM provides support for implementors to uniquely identify a legal agreement solely through the specification of the agreement identification features, as represented in the LegalAgreementBase abstract data type, which is illustrated below:

type LegalAgreementBase:
  agreementDate date (0..1)
  effectiveDate date (0..1)
  identifier Identifier (0..*)
  legalAgreementIdentification LegalAgreementIdentification (1..1)
  contractualParty Party (2..2)
   [metadata reference]
  otherParty PartyRole (0..*)

As indicated by the cardinality for the attributes in this data type, all legal agreements must contain an agreement date, two contractual parties, and information indicating the published form of market standard agreement being used (including the name and publisher of the legal agreement being specified in the agreementIdentification attribute). Provision is made for further information to be captured, for example an agreement identifier, which is an optional attribute."
What is Related Agreement of legal agreements of common domain model,"Related agreements attribute is used to specify any higher-level agreement(s) that may govern the agreement, either as a reference to such agreements when specified as part of the CDM, or through identification of some of the key terms of those agreements."
What is Umbrella Agreement of legal agreements of common domain model,"UmbrellaAgreement is a data type used to specify the applicability of Umbrella Agreement terms, relevant specific language, and underlying entities associated with the umbrella agreement.

The below snippet represents the UmbrellaAgreement data type.

type UmbrellaAgreement:
  isApplicable boolean (1..1)
  language string (0..1)
  parties UmbrellaAgreementEntity (0..*)"
What is Agreement Content of legal agreements of common domain model,"AgreementTerms is used to specify the content of a legal agreement in the CDM. There are two components to agreement terms, as shown in the code snippet below:

type AgreementTerms:
  agreement Agreement (1..1)
  clauseLibrary boolean (0..1)
  counterparty Counterparty (2..2)"
What is Agreement of legal agreements of common domain model,"Agreement is a data type used to specify the individual elections contained within the legal agreement. It contains a set of encapsulated data types, each containing the elections used to define a specific group of agreements.

type Agreement:
  creditSupportAgreementElections CreditSupportAgreementElections (0..1)
  collateralTransferAgreementElections CollateralTransferAgreementElections (0..1)
  securityAgreementElections SecurityAgreementElections (0..1)
  masterAgreementSchedule MasterAgreementSchedule (0..1)
  transactionAdditionalTerms TransactionAdditionalTerms (0..1)
  condition: one-of"
What is Counterparty of legal agreements of common domain model,"Each counterparty to the agreement is assigned an enumerated value of either Party1 or Party2 through the association of a CounterpartyRoleEnum with the corresponding Party. The CounterpartyRoleEnum value is then used to specify elections throughout the rest of the document.

enum CounterpartyRoleEnum:
  Party1
  Party2

type Counterparty:
  role CounterpartyRoleEnum (1..1)
  partyReference Party (1..1)
   [metadata reference]"
What is Modelling Approach of legal agreements of common domain model,"In many cases the pre-printed clauses in legal agreement templates for OTC Derivatives offer pre-defined elections that the parties can select. In these cases, the clauses are explicitly identified in the agreement templates, including the potential values for each election (e.g. an election from a list of options or a specific type of information such as an amount, date or city). The design of the elective provisions in the CDM to represent these instances is a direct reflection of the choices in the clause and uses boolean attributes or enumeration lists to achieve the necessary outcome.

However, in some cases, the agreement template may identify a clause but not all the applicable values, e.g. when a single version of a clause term is provided with a space for parties to agree on a term that is not defined in the template. In order to support these instances, the CDM uses string attributes to capture the clause in a free text format."
What is Election Structure of legal agreements of common domain model,"For ease of reference, the structure of the elections contained within each agreement data type in the CDM are modelled to reflect the structure of the legal agreements that they represent. Each data type contains a set of elections or election families which can be used to represent the clauses contained within the corresponding legal agreement, regardless of vintage or governing law.

This approach allows the representation of elections in the CDM to focus on their intended business outcome in order to better support the standardisation of related business processes.

For example, CreditSupportAgreementElections , which is one of the four agreement types, contains all the elections that may be applicable to a credit support agreement and can be used to define any of the Initial Margin or Variation Margin Credit Support Agreements supported by the CDM:

ISDA 2016 Phase One Credit Support Annex (""CSA"") for Initial Margin (""IM"") (Security Interest -- New York Law)
ISDA 2016 Phase One Credit Support Deed (""CSD"") for IM (Security Interest -- English Law)
ISDA 2016 Phase One CSA for IM (Loan -- Japanese Law)
ISDA 2018 CSA for IM (Security Interest -- New York Law)
ISDA 2018 CSD for IM (Security Interest -- English Law)
ISDA 2016 CSA for Variation Margin (""VM"") (Security Interest - New York Law)
ISDA 2016 CSA for VM (Title Transfer -- English Law)
ISDA 2016 CSA for VM (Loan -- Japanese Law)
ISDA 2016 CSA for VM (Title Transfer -- Irish Law)
ISDA 2016 CSA for VM (Title Transfer -- French Law)
condition AgreementVerification:
  if agreementTerms -> agreement -> securityAgreementElections exists
  then legalAgreementIdentification -> agreementName -> agreementType = LegalAgreementTypeEnum->SecurityAgreement


The validation in this case requires that if the securityAgreementElections attribute is populated, then the value in LegalAgreementNameEnum must be SecurityAgreement .

Selected examples from two of the agreement data types are explained in the following sections to illustrate the overall approach.

The development of a digital data standard for representation of eligible collateral schedules is a crucial component required to drive digital negotiation, straight through processing, and digitisation of collateral management. The standard representation provided within the CDM allows institutions involved in the collateral workflow cycle to exchange eligible collateral information accurately and efficiently in digital form. The EligibleCollateral data type is a root type with one attribute, as shown below:

type EligibleCollateralSpecification:
   [rootType]
   [metadata key]
   identifier Identifier (0..*)
   party Party (0..2)
   counterparty Counterparty (0..2)
   criteria EligibleCollateralCriteria (1..*)

The EligibleCollateralCriteria data type contains the following key components to allow the digital representation of the detailed criteria reflected in the legal agreement:

Collateral Issuer Criteria specifies criteria that the issuer of an asset (if any) must meet when defining collateral eligibility for that asset.
Collateral Product Criteria specifies criteria that the product must meet when defining collateral eligibility.
Collateral Treatment specifies criteria for the treatment of collateral assets, including whether the asset is identified as eligible or ineligible, and treatment when posted.
The following code snippets represent these three components of the eligible collateral model. These components are assembled under the EligibleCollateralCriteria data type, which is contained within the postingObligationElection component of the credit support agreement elections described above.

type EligibleCollateralCriteria extends CollateralCriteriaBase:
   treatment CollateralTreatment (1..1)

type CollateralCriteriaBase:
   issuer IssuerCriteria (0..*)
   asset AssetCriteria (0..*)
   appliesTo CounterpartyRoleEnum (0..2)

type IssuerCriteria:
  issuerType CollateralIssuerType (0..*)
  issuerCountryOfOrigin ISOCountryCodeEnum (0..*)
  issuerName LegalEntity (0..*)
  issuerAgencyRating AgencyRatingCriteria (0..*)
  sovereignAgencyRating AgencyRatingCriteria (0..*)
  counterpartyOwnIssuePermitted boolean (0..1)

type AssetCriteria:
  collateralAssetType AssetType (0..*)
  assetCountryOfOrigin ISOCountryCodeEnum (0..*)
  denominatedCurrency CurrencyCodeEnum (0..*)
  agencyRating AgencyRatingCriteria (0..*)
  maturityType MaturityTypeEnum (0..1)
  maturityRange PeriodRange (0..1)
  productIdentifier ProductIdentifier (0..*)
  collateralTaxonomy CollateralTaxonomy (0..*)
  domesticCurrencyIssued boolean (0..1)
  listing ListingType (0..1)

type CollateralTreatment:
  valuationTreatment CollateralValuationTreatment (0..1)
  concentrationLimit ConcentrationLimit (0..*)
  isIncluded boolean (1..1)"
What is the Granularity of process model in common domain model,"It is important for implementors of the CDM to understand the scope of the model with regard to specifications and executable code for the above list of post-trade lifecycle processes.

The CDM process model leverages the function component of the Rosetta DSL. A function receives a set of input values and applies logical instructions to return an output. The input and output are both CDM objects (including basic types). While a function specifies its inputs and output, its logic may be fully defined or only partially defined depending on how much of the output's attribute values it builds. Unspecified parts of a process represent functionality that firms are expected to implement, either internally or through third-parties such as utilities.

It is not always possible or practical to fully specify the business logic of a process from a model. Parts of processes or sub-processes may be omitted from the CDM for the following reasons:

The sub-process is not needed to create a functional CDM output object.
The sub-process has already been defined and its implementation is widely adopted by the industry.
The sub-process is specific to a firm's internal process and therefore cannot be specified in an industry standard.
Given these reasons, the CDM process model focuses on the most critical data and processes required to create functional objects that satisfy the below criterion:

All of the qualifiable constituents (such as BusinessEvent and Product) of a function's output can be qualified, which means that they evaluate to True according to at least one of the applicable Qualification functions.
Lineage and cross-referencing between objects is accurate for data integrity purposes.
For any remaining data or processes, implementors can populate the remaining attribute values required for the output to be valid by extending the executable code generated by the process model or by creating their own functions.

For the trade lifecycle processes that are in scope, the CDM process model covers the following sub-process components, which are each detailed in the next sections:

Validation process
Calculation process
Event creation process"
What is the Validation Process of process model in common domain model,"In many legacy models and technical standards, validation rules are generally specified in text-based documentation, which requires software engineers to evaluate and translate the logic into code. The frequently occuring result of this human interpretation process is inconsistent enforcement of the intended logic.

By contrast, in the CDM, validation components are an integral part of the process model specifications and are distributed as executable code in the Java representation of the CDM. The CDM validation components leverage the validation components of the Rosetta DSL."
What is the Product Validation of process model in common domain model,"As an example, the FpML ird validation rule #57, states that if the calculation period frequency is expressed in units of month or year, then the roll convention cannot be a weekday. A machine readable and executable definition of that specification is provided in the CDM, as a condition attached to the CalculationPeriodFrequency type:

condition FpML_ird_57:
  if period = PeriodExtendedEnum -> M or period = PeriodExtendedEnum -> Y
  then rollConvention <> RollConventionEnum -> NONE
    and rollConvention <> RollConventionEnum -> SFE
    and rollConvention <> RollConventionEnum -> MON
    and rollConvention <> RollConventionEnum -> TUE
    and rollConvention <> RollConventionEnum -> WED
    and rollConvention <> RollConventionEnum -> THU
    and rollConvention <> RollConventionEnum -> FRI
    and rollConvention <> RollConventionEnum -> SAT
    and rollConvention <> RollConventionEnum -> SUN"
What is the Calculation Process of process model in common domain model,"The CDM provides certain ISDA Definitions as machine executable formulas to standardise the industry calculation processes that depend on those definitions. Examples include the ISDA 2006 definitions of Fixed Amount and Floating Amount , the ISDA 2006 definitions of Day Count Fraction rules, and performance calculations for Equity Swaps. The CDM also specifies related utility functions.

These calculation processes leverage the calculation function component of the Rosetta DSL which is associated to a [calculation] annotation."
What is the Base Libraries - Vector Math of process model in common domain model,"The CDM includes a very basic library for performing vector math. This is intended to support more complex calculations such as daily compounded floating amounts. The CDM includes a basic implementation of these functions in Java, and allows individual implementations to substitute their own more robust representations.

A small library of functions for working with vectors (ordered collections of numbers) has been added to CDM to support Rosetta functions needing to perform complex mathematical operations. Anticipated uses include averaging and compounding calculations for floating amounts, but the functions are designed to be general use.

The functions are located in base-math-func.

Functions include:

VectorOperation: Generates a result vector by applying the supplied arithmetic operation to each element of the supplied left and right vectors in turn. i.e. result[n] = left[n] [op] right[n], where [op] is the arithmetic operation defined by arithmeticOp. This function can be used to, for example, multiply or add two vectors.
VectorScalarOperation: Generates a result vector by applying the supplied arithmetic operation and scalar right value to each element of the supplied left vector in turn. i.e. result[n] = left[n][op] right, where [op] is the arithmetic operation defined by arithmeticOp. This function can be used to, for example, multiply a vector by a scalar value, or add a scalar to a vector.
VectorGrowthOperation: Generates a result vector by starting with the supplied base value (typically 1), and then multiplying it in turn by each growth factor, which is typically a number just above 1. For instance, a growth factor of 1.1 represents a 10% increase, and 0.9 a 10% decrease. The results will show the successive results of applying the successive growth factors, with the first value of the list being the supplied baseValue, and final value of the results list being the product of all of the supplied values. i.e. result[1] = baseValue * factor[1], result[n] = result[n-1] * factor[n]. The resulting list will have the one more element than the supplied list of factors. This function is useful for performing compounding calculations.
AppendToVector: Appends a single value to a vector.
Also a new scalar functions has been added to better support floating rate processing:

RoundToPrecision: Rounds a supplied number to a specified precision (in decimal places) using a roundingMode of type RoundingDirectionEnum. This is similar to RoundToNearest but takes a precision rather than an amount, and uses a different rounding mode enumeration that supports more values."
What is the Base Libraries - Date Math of process model in common domain model,"The CDM includes a very basic library for performing date math. This is intended to support more complex calculations such as daily compounded floating amounts. The CDM includes a basic implementation of these functions in Java, and allows individual implementations to substitute their own more robust representations.

A small library of functions for working with dates and lists of dates has been added to CDM to support Rosetta functions needing to perform date mathematics. Anticipated uses include date list generation for modular rate calculations for floating amounts, but the functions are designed to be general use.

There is a basic Java language implementation that can be used, or users can provide their own implementations of these functions using a more robust date math library.

The functions are located in base-datetime-func.

Functions include:

GetAllBusinessCenters: Returns a merged list of BusinessCenterEnums for the supplied BusinessCenters.
BusinessCenterHolidaysMultiple: Returns a sorted list of holidays for the supplied business centers.
BusinessCenterHolidays: Returns a list of holidays for the supplied business center.
DayOfWeek: Returns the day of week corresponding to the supplied date.
AddDays: Adds the specified number of calendar days to the supplied date. A negative number will generate a date before the supplied date.
DateDifference: Subtracts the two supplied dates to return the number of calendar days between them . A negative number implies first is after second.
LeapYearDateDifference: Subtracts the two supplied dates to return the number of leap year calendar days between them (that is, the number of dates that happen to fall within a leap year). A negative number implies firstDate is after secondDate.
AppendDateToList: Add a date to a list of dates.
PopOffDateList: Remove last element from a list of dates.
The following are implemented in Rosetta based on the above primitives:

IsWeekend: Returns whether the supplied date is a weekend. This implementation currently assumes a 5 day week with Saturday and Sunday as holidays. A more sophisticated implementation might use the business centers to determine which days are weekends, but most jurisdictions where derivatives are traded follow this convention.
IsHoliday: Returns whether a day is a holiday for the specified business centers.
IsBusinessDay: Returns an indicator of whether the supplied date is a good business date given the supplied business centers. True => good date, i.e. not a weekend or holiday. False means that it is either a weekend or a holiday.
AddBusinessDays: Returns a good business date that has been offset by the given number of business days given the supplied business centers. A negative value implies an earlier date (before the supplied originalDate), and a positive value a later date (after the supplied date).
GenerateDateList: Creates a list of good business days starting from the startDate and going to the end date, inclusive, omitting any days that are weekends or holidays according to the supplied business centers."
What is the Base Libraries - Daycounting of process model in common domain model,"The CDM includes a library for performing day counting calculations.

It includes functions as follows: * YearFraction: The fraction of a year represented by a date range. * YearFractionForOneDay[: Return the year fraction represented by a single day, i.e. 1 / dayCountBasis, where dayCountBasis represents the denominator of the day count fraction. This perhaps should take into account leap years, though the ISDA compounding formulas do not cover ACT basis at the moment. *DayCountBasis: Return the day count basis (the denominator of the day count fraction) for the day count fraction."
What is the Floating Rate Option/Index Features of process model in common domain model,"The CDM includes features for retrieving information about floating rate options and for calculating custom (""modular"") floating rates.

Functions for retrieving information about FROs include:

IndexValueObservation: Retrieve the values of the supplied index on the specified observation date.
IndexValueObservationMultiple: Retrieve the values of the supplied index on the specified observation dates.
FloatingRateIndexMetadata: Retrieve all available metadata for the floating rate index.
ValidateFloatingRateIndexName: Return whether the supplied floating rate index name is valid for the supplied contractual definitions.
Functions for calculating modular floating rates include:

EvaluateCalculatedRate: Evaluate a calculated rate as described in the 2021 ISDA Definitions, Section 7
GenerateObservationDatesAndWeights: Apply shifts to generate the list of observation dates and weights for each of those dates.
ComputeCalculationPeriod: Determine the calculation period to use for computing the calculated rate (it may not be the same as the normal calculation period, for instance if the rate is set in advance)
DetermineObservationPeriod: Determine any applicable offsets/shifts for the period for observing an index, and then generate the date range to be used for observing the index, based on the calculation period, plus any applicable offsets/shifts.
GenerateObservationPeriod: Generate the date range to be used for observing the index, based on the calculation period, plus any applicable offsets/shifts.
GenerateObservationDates: Generate the list of observation dates given an observation period.
DetermineWeightingDates: Determine the dates to be used for weighting observations.
ProcessObservations: Apply daily observation parameters to rate observation. These are discussed in the 2021 ISDA Definitions, section 7.2.3 and 7.2.4.
GenerateWeights: Recursively creates a list of weights based on the date difference between successive days.
ApplyCompoundingFormula: Implements the compounding formula: Product of ( 1 + (rate * weight) / basis), then backs out the final rate. This is used to support section 7.3 of the 2021 ISDA Definitions.
ApplyAveragingFormula: Implements the weighted arithmetic averaging formula. Sums the weighted rates and divides by the total weight. This is used to support section 7.4 of the 2021 ISDA Definitions."
What is the Fixed Amount and Floating Amount Definitions of process model in common domain model,"The CDM includes preliminary features for calculating fixed and floating amounts for interest rate payouts.

Base calculation functions include:

FixedAmountCalculation: Calculates the fixed amount for a calculation period by looking up the notional and the fixed rate and multiplying by the year fraction
GetFixedRate: Look up the fixed rate for a calculation period
FloatingAmountCalculation: Calculate a floating amount for a calculation period by determining the raw floating rate, applying any rate treatments, looking up the calculation period notional, then performing the multiplication of the notional, rate, and year fraction. Floating amount calculations are described in the 2021 ISDA Definitions in Section 6 and 7.
GetNotionalAmount: Look up the notional amount in effect for a calculation period
GetQuantityScheduleStepValues: Find all schedule step values whose stepDate is before or equal to the supplied periodStartDate. Returns a list of step values starting from the initial quantity value, to the last step value before the periodStartDate.
CalculateYearFraction: Calculate the year fraction for a single calculation period, by invoking the base year fraction logic
Floating rate processing an calculation functions include:

DetermineFloatingRateReset: Get the value of a floating rate by either observing it directly or performing a rate calculation. This function works differently depending on the rate category and style, as described in the 2021 ISDA Definitions, Section 6.6.
GetFloatingRateProcessingType: Get a classification of the floating rate is processed. This is based on FRO category, style, and calculation method, as described in the 2021 ISDA Definitions Section 6.6. The categorization information is obtained from the FRO metadata.
ProcessFloatingRateReset: Entry point for the function that performs the floating rate resetting operation. There are different variations depending on the processing type (e.g. screen rate, OIS, modular calculated rate).
GetCalculatedFROCalculationParameters: Initialize a calculation parameters block for an OIS or a daily average rate. Used to support FROs that include an embedded calculation.
ProcessFloatingRateReset(processingType: FloatingRateIndexProcessingTypeEnum->CompoundIndex): Call the compounded index processing logic to calculate the reset
EvaluateScreenRate: Evaluate/lookup the value of a screen rate
DetermineResetDate: Determine the value of the reset date given a reset dates structure and a calculation period for which it's needed. Reset dates are defined in the 2021 ISDA Definition in Section 6.5.5.
DetermineFixingDate: Determine the observation (fixing) date needed given a reset dates structure and a reset date.
GetFloatingRateProcessingParameters: Determine the processing parameters to use from the InterestRatePayout by looking them up if necessary from the corresponding schedules in the interest rate stream
SpreadAmount: Look up the spread amount for a calculation period.
MultiplierAmount: Look up the multiplier amount for a calculation period.
CapRateAmount: Look up the cap rate amount for a calculation period.
FloorRateAmount: Look up the floor rate amount for a calculation period.
GetRateScheduleAmount: Look up an amount for a calculation period from a rate schedule
ApplyFloatingRateProcessing: Perform rate treatments on floating rates, such as applying spreads, multipliers, caps and floors, rounding, and negative interest treatment.
ApplyFloatingRatePostSpreadProcessing: Perform post-spread rate treatments on floating rates, such as applying caps and floors, rounding, and negative interest treatment.
ApplyCapsAndFloors: Apply any cap or floor rate as a constraint on a regular swap rate, as discussed in the 2021 ISDA Definitions, section 6.5.8 and 6.5.9
The CDM expressions of FixedAmount and FloatingAmount are similar in structure: a calculation formula that reflects the terms of the ISDA 2006 Definitions and the arguments associated with the formula.

func FloatingAmount:
  [calculation]
  inputs:
      interestRatePayout InterestRatePayout (1..1)
      rate number (0..1)
      notional number (0..1)
      date date (0..1)
      calculationPeriodData CalculationPeriodData (0..1)
  output:
      floatingAmount number (1..1)

  alias calculationPeriod:
      if calculationPeriodData exists then calculationPeriodData else CalculationPeriod(interestRatePayout -> calculationPeriodDates, date)
  alias calcPeriodBase : Create_CalculationPeriodBase(calculationPeriod)
  alias floatingCalc : FloatingAmountCalculation(interestRatePayout, calcPeriodBase, False, notional, rate)

  set floatingAmount : floatingCalc-> calculatedAmount

ApplyUSRateTreatment: Apply the US rate treatment logic where applicable (Bond Equivalent Yield, Money Market Yield, as described in the 2021 ISDA Definitions, section 6.9. (NB: this function does not have an implementation.)
ApplyFinalRateRounding: Apply the final rate rounding treatment logic as described in the 2021 ISDA Definitions, section 4.8.1.
Most of the above have a preliminary implementation for feedback. A few are only defined as ""do-nothing"" interfaces, and users needing these features would need to implement the functions."
What is the Year Fraction of process model in common domain model,"The CDM process model incorporates calculations that represent the set of day count fraction rules specified as part of the ISDA 2006 Definitions, e.g. the ACT/365.FIXED and the 30E/360 day count fraction rules. Although these rules are widely accepted in international markets, many of them have complex nuances which can lead to inconsistent implementations and potentially mismatched settlements.

For example, there are three distinct rule sets in which the length of each month is generally assumed to be 30 days for accrual purposes (and each year is assumed to be 360 days). However there are nuances in the rule sets that distinguish the resulting calculations under different circumstances, such as when the last day of the period is the last day of February. These distinct rule sets are defined by ISDA as 30/360 (also known as 30/360 US), 30E/360 (formerly known as 30/360 ICMA or 30/360 Eurobond), and the 30E/360.ISDA.

The CDM process model eliminates the need for implementors to interpret the logic and write unique code for these rules. Instead, it provides a machine-readable expression that generates executable code, such as the example below:

func YearFraction(dayCountFractionEnum: DayCountFractionEnum -> _30E_360):
   [calculation]

   alias startYear: startDate -> year
   alias endYear: endDate -> year
   alias startMonth: startDate -> month
   alias endMonth: endDate -> month
   alias endDay: Min(endDate -> day, 30)
   alias startDay: Min(startDate -> day, 30)

   set result:
       (360 * (endYear - startYear) + 30 * (endMonth - startMonth) + (endDay - startDay)) / 360"
What is the Utility Function of process model in common domain model,"CDM elements often need to be transformed by a function to construct the arguments for a formula in a calculation. A typical example is the requirement to identify a period start date, end date, and other date-related attributes required to compute a cashflow amount in accordance with a schedule (as illustrated in the day count fraction calculation shown above). The CDM has two main types to address this requirement:

CalculationPeriodDates specifies the inputs required to construct a calculation period schedule
CalculationPeriodData specifies actual attribute values of a calculation period such as start date, end date, etc.
The CalculationPeriod function receives the CalculationPeriodDates and the current date as the inputs and produces the CalculationPeriodData as the output, as shown below:

func CalculationPeriod:
  inputs:
    calculationPeriodDates CalculationPeriodDates (1..1)
    date date (1..1)
  output: result CalculationPeriodData (1..1)"
What is the Equity Performance of process model in common domain model,"The CDM process model includes calculations to support the equity performance concepts applied to reset and pay cashflows on Equity Swaps. Those calculations follow the definitions as normalised in the new 2018 ISDA CDM Equity Confirmation for Security Equity Swap (although this is a new template that is not yet in use across the industry).

Some of those calculations are presented below:

func EquityCashSettlementAmount:
    inputs:
        tradeState TradeState (1..1)
        date date (1..1)
    output:
        equityCashSettlementAmount Transfer (1..1)

    alias equityPerformancePayout:
        tradeState -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> performancePayout only-element
    alias equityPerformance:
        EquityPerformance(tradeState ->trade, tradeState -> resetHistory only-element -> resetValue, date)
    alias payer:
        ExtractCounterpartyByRole( tradeState -> trade -> tradableProduct -> counterparty, equityPerformancePayout -> payerReceiver -> payer ) -> partyReference
    alias receiver:
        ExtractCounterpartyByRole( tradeState -> trade -> tradableProduct -> counterparty, equityPerformancePayout -> payerReceiver -> receiver ) -> partyReference

    set equityCashSettlementAmount -> quantity -> value:
        Abs(equityPerformance)
    set equityCashSettlementAmount -> quantity -> unit -> currency:
        ResolveEquityInitialPrice(
           tradeState -> trade -> tradableProduct -> tradeLot only-element -> priceQuantity -> price
        ) -> unit -> currency
    set equityCashSettlementAmount -> payerReceiver -> payerPartyReference:
        if equityPerformance >= 0 then payer else receiver
    set equityCashSettlementAmount -> payerReceiver -> receiverPartyReference:
        if equityPerformance >= 0 then receiver else payer
    set equityCashSettlementAmount -> settlementDate -> adjustedDate:
        ResolveCashSettlementDate(tradeState)
    set equityCashSettlementAmount -> settlementOrigin -> performancePayout:
        equityPerformancePayout as-key


func RateOfReturn:
   inputs:
       initialPrice PriceSchedule (1..1)
       finalPrice PriceSchedule (1..1)
   output:
       rateOfReturn number (1..1)

   alias initialPriceValue:
       initialPrice->value
   alias finalPriceValue:
       finalPrice->value
   set rateOfReturn:
       if finalPriceValue exists and initialPriceValue exists and initialPriceValue > 0 then
           (finalPriceValue - initialPriceValue) / initialPriceValue"
What is the Billing of process model in common domain model,"The CDM process model includes calculations to support the billing event consisting of the individual amounts that need to be settled in relation to a portfolio of Security Loans. These calculations leverage the FixedAmount, FloatingAmount and Day Count Fraction calculations described earlier in the documentation. A functional model is provided to populate the SecurityLendingInvoice data type following the definitions as normalised in the ISLA best practice handbook

The data type and function to generate a Security Lending Invoice:

type SecurityLendingInvoice:
  [rootType]
  [metadata key]
  sendingParty Party (1..1)
  receivingParty Party (1..1)
  billingStartDate date (1..1)
  billingEndDate date (1..1)
  billingRecord BillingRecord (1..*)
  billingSummary BillingSummary (1..*)

func Create_SecurityLendingInvoice:
   inputs:
     instruction BillingInstruction (1..1)
   output:
     invoice SecurityLendingInvoice (1..1)

   set invoice -> sendingParty:
     instruction -> sendingParty
   set invoice -> receivingParty:
     instruction -> receivingParty
   set invoice -> billingStartDate:
     instruction -> billingStartDate
   set invoice -> billingEndDate:
     instruction -> billingEndDate
   add invoice -> billingRecord:
     Create_BillingRecords( instruction -> billingRecordInstruction )
   add invoice -> billingSummary:
     Create_BillingSummary( invoice -> billingRecord )"
What is the Primitive Creation of process model in common domain model,"Primitive creation functions can be thought of as the fundamental mathematical operators that operate on a trade state. While a primitive event object describes each state transition in terms of before and after trade states, a primitive creation function defines the logic to transition from that before trade state to the after trade state, using a set of instructions.

An example of such use is captured in the reset event of an Equity Swap. The reset is processed in following steps:

Resolve the Observation that contains the equity price, using specific product definition terms defined on EquityPayout.
Construct a Reset using the equity price on Observation. In this scenario, the reset value is the equity price.
Append Reset onto TradeState, creating a new instance of TradeState.
At the end of each period in the life of the Equity Swap, the reset process will append further reset values onto the trade state. The series of equity prices then supports equity performance calculation as each reset value will represent the equity price at the end of one period and the start of the next.

These above steps are codified in the Create_Reset function, which defines how the Reset instance should be constructed.

func Create_Reset:
    inputs:
        instruction ResetInstruction (1..1)
        tradeState TradeState (1..1)
    output:
        reset TradeState (1..1)

    alias payout:
       instruction -> payout

   alias observationDate:
       if instruction -> rateRecordDate exists
       then instruction -> rateRecordDate
       else instruction -> resetDate

   alias observationIdentifiers:
       if payout -> performancePayout count = 1 then ResolvePerformanceObservationIdentifiers(payout -> performancePayout only-element, instruction -> resetDate)
       else if payout -> interestRatePayout exists then ResolveInterestRateObservationIdentifiers(payout -> interestRatePayout only-element, observationDate)

   alias observation:
       ResolveObservation([observationIdentifiers], empty)

   set reset:
       tradeState

   add reset -> resetHistory:
       if payout -> performancePayout count = 1 then ResolvePerformanceReset(payout -> performancePayout only-element, observation, instruction -> resetDate)
       else if payout -> interestRatePayout exists then ResolveInterestRateReset(payout -> interestRatePayout, observation, instruction -> resetDate, instruction -> rateRecordDate)


First, ResolvePerformanceObservationIdentifiers defines the specific product definition terms used to resolve ObservationIdentifiers. An ObservationIdentifier uniquely identifies an Observation, which inside holds a single item of market data and in this scenario will hold an equity price.

Specifying precisely which attributes from PerformancePayout should be used to resolve the equity price is important to ensure consistent equity price resolution for all model adopters.

func ResolvePerformanceObservationIdentifiers:
    inputs:
        payout PerformancePayout (1..1)
        adjustedDate date (1..1)
    output:
        identifiers ObservationIdentifier (1..1)

    alias adjustedFinalValuationDate:
        ResolveAdjustableDate( payout -> valuationDates -> valuationDatesFinal -> valuationDate )

    alias valuationDates:
        if adjustedDate < adjustedFinalValuationDate then
            payout -> valuationDates -> valuationDatesInterim
        else
            payout -> valuationDates -> valuationDatesFinal

    add identifiers -> observable -> productIdentifier:
        payout -> underlier -> security -> productIdentifier

    set identifiers -> observationDate:
        AdjustedValuationDates( payout -> valuationDates )
            filter item <= adjustedDate
            then last

    set identifiers -> observationTime:
        ResolvePerformanceValuationTime(valuationDates -> valuationTime,
            valuationDates -> valuationTimeType,
            identifiers -> observable -> productIdentifier only-element,
            valuationDates -> determinationMethod )

    set identifiers -> determinationMethodology -> determinationMethod:
        valuationDates -> determinationMethod


ResolveObservation provides an interface for adopters to integrate their market data systems. It specifies the input types and the output type, which ensures the integrity of the observed value.

func ResolveObservation:
    inputs:
        identifiers ObservationIdentifier (1..*)
        averagingMethod AveragingCalculationMethod (0..1)
    output:
        observation Observation (1..1)

The construction of the Reset in our scenario then becomes trivial, once the equity price has been retrieved, as the equity price and reset date are simply assigned to the corresponding attributes on the Reset.

func ResolvePerformanceReset:
    inputs:
        performancePayout PerformancePayout (1..1)
        observation Observation (1..1)
        date date (1..1)
    output:
        reset Reset (1..1)

    set reset -> resetValue:
        observation -> observedValue

    set reset -> resetDate:
        date

    add reset -> observations:
        observation"
What is reference data model in common domain model,"The CDM only integrates the reference data components that are specifically needed to model the in-scope products, events, legal agreements and function components.

This translates into the representation of the party and legal entity.

Parties are not explicitly qualified as a legal entity or a natural person, although the model provides the ability to associate a person (or set of persons) to a party, which use case would imply that such party would be a legal entity (even if not formally specified as such).

The LegalEntity type is used when only a legal entity reference is appropriate i.e. the value would never be that of a natural person.

type Party:
  [metadata key]
  partyId PartyIdentifier (1..*)
  name string (0..1)
    [metadata scheme]
  businessUnit BusinessUnit (0..*)
  person NaturalPerson (0..*)
  personRole NaturalPersonRole (0..*)
  account Account (0..1)
  contactInformation ContactInformation (0..1)

type NaturalPerson:
  [metadata key]
  personId PersonIdentifier (0..*)
    [metadata scheme]
  honorific string (0..1)
  firstName string (0..1)
  middleName string (0..*)
  initial string (0..*)
  surname string (0..1)
  suffix string (0..1)
  dateOfBirth date (0..1)

type LegalEntity:
  [metadata key]
  entityId string (0..*)
    [metadata scheme]
  name string (1..1)
    [metadata scheme]"
What is Mapping (Synonym) in common domian model,"In order to facilitate the translation of existing industry messages (based on open standards or proprietary ones) into CDM, the CDM is mapped to a set of those alternative data representations using the Rosetta DSL synonym feature, as described in the Mapping Component Section.

The following set of synonym sources are currently in place for the CDM:

FpML standard (synonym source: FpML_5_10): synonyms to the version 5.10 of the FpML standard
FIX standard (synonym source: FIX_5_0_SP2): synonyms to the version 5.0 SP2 of the FIX protocol
ISO 20022 standard (synonym source: ISO_20022): synonyms to the ISO 20022 reporting standard, with no version reference at present
Workflow event (synonym source: Workflow_Event): synonyms to the event.xsd schema used internally in Rosetta to ingest sample lifecycle events
DTCC (synonym sources: DTCC_11_0 and DTCC_9_0): synonyms to the OTC_Matching_11-0.xsd schema used for trade matching confirmations, and to the OTC_Matching_9-0.xsd schema used for payment notifications, both including the imported FpML schema version 4.9.
CME (synonym sources: CME_ClearedConfirm_1_17 and CME_SubmissionIRS_1_0): synonyms to the cme-conf-ext-1-17.xsd schema (including the imported FpML schema version 5.0) used for clearing confirmation, and to the bloombergTradeFixml schema (including the imported FpML schema version 4.6) used for clearing submission
AcadiaSoft (synonym source: AcadiaSoft_AM_1_0): synonyms to version 1.0 of AcadiaSoft Agreement Manager
ISDA Create (synonym source: ISDA_Create_1_0): synonyms to version 1.0 of the ISDA Create tool for Initial Margin negotiation
ORE (synonym source: ORE_1_0_39): synonyms to version 1.0.39 of the ORE XML Model
Those synonym sources are listed as part of a configuration file in the CDM using a special synonym source enumeration, so that the synonym source value can be controlled when editing synonyms."
What is the scope of process model in common domain model,"Scope
The scope of the process model has two dimensions:

Coverage - which industry processes should be covered.
Granularity - at which level of detail each process should be specified."
What is the Coverage of process model in common domain model,"The CDM process model currently covers the post-trade lifecycle of securities, contractual products, and foreign exchange. Generally, a process is in-scope when it is already covered in ISDA Documentation or other technical documents. For example, the following processes are all in scope:

Trade execution and confirmation
Clearing
Allocation
Reallocation
Settlement (including any future contingent cashflow payment)
Return (settlement of the part and/or full return of the loaned security as defined by a Securities Lending transaction.)
Billing (calculation and population of invoicing for Securities Lending transactions)
Exercise of options
Margin calculation
Regulatory reporting (although covered in a different documentation section)"
What is Business Event in event model of the common domain model,"Business events are built according to the following principles:

A business event is specified functionally by composing primitive operators, each of which representing a fundamental change to the trade state and described by a primitive instruction.
Business event qualification is inferred from those primitive components and, in some relevant cases, from an additional intent qualifier associated with the business event. The inferred value is populated in the eventQualifier attribute.
type BusinessEvent extends EventInstruction:
  [metadata key]
  [rootType]

  eventQualifier string (0..1)
  after TradeState (0..*)

type Instruction:
  [rootType]
  primitiveInstruction PrimitiveInstruction (0..1)
  before TradeState (0..1)
    [metadata reference]

The only mandatory attributes of a business event are:

The event instruction. This is a list of Instruction objects, each representing a composite primitive instruction applied to a single (before) trade state. This attribute is of multiple cardinality, so a business event may impact multiple trades concurrently and result in multiple (after) trade states.
The event date. The time dimension has been purposely ommitted from the event's attributes. That is because, while a business event has a unique date, several time stamps may potentially be associated to that event depending on when it was submitted, accepted, rejected etc, all of which are workflow considerations.
Note: The primitives attribute corresponds to a previous impleme"
What is Event Composition in event model of the common domain model,"An example composition of primitive instructions to represent a complete lifecycle event is shown below. The event represents the partial novation of a contract, which comprises the following:

a split primitive
a quantity change primitive applied to each post-split trade, where the total quantity should match the quantity of the original trade and none of the quantities is 0. A quantity of 0 for the remaining trade would result in a termination and represent a full novation.
a party change primitive applied to the post-split trade whose quantity corresponds to the novated quantity.
""primitiveInstruction"" : {
     ""split"" : {
       ""breakdown"" : [ {
         ""partyChange"" : {
           ""counterparty"" : {
             ""partyReference"" : {
               ""value"" : {
                 ""name"" : {
                   ""value"" : ""Bank Z""
                 },
                 ""partyId"" : [ {
                   ""identifier"" : {
                     ""value"" : ""LEI3RPT0003""
                   },
                   ""identifierType"" : ""LEI"",
                 } ]
               }
             },
             ""role"" : ""PARTY_1""
           },
           ""tradeId"" : [ {
             ""assignedIdentifier"" : [ {
               ""identifier"" : {
                 ""value"" : ""LEI3RPT0003DDDD""
               },
               ""identifierType"" : ""UNIQUE_TRANSACTION_IDENTIFIER""
             } ],
             ""issuer"" : {
               ""value"" : ""LEI3RPT0003""
             },
           } ]
         },
         ""quantityChange"" : {
           ""change"" : [ {
             ""quantity"" : [ {
               ""value"" : {
                 ""amount"" : 5000,
                 ""unitOfAmount"" : {
                   ""currency"" : {
                     ""value"" : ""USD""
                   }
                 }
               }
             } ]
           } ],
           ""direction"" : ""REPLACE""
         }
       }, {
         ""quantityChange"" : {
           ""change"" : [ {
             ""quantity"" : [ {
               ""value"" : {
                 ""amount"" : 8000,
                 ""unitOfAmount"" : {
                   ""currency"" : {
                     ""value"" : ""USD""
                   }
                 }
               }
             } ]
           } ],
           ""direction"" : ""REPLACE""
         }
       } ]
     }
   }

A business event is atomic, i.e. its primitive components cannot happen independently. They either all happen together or not at all. In the above partial novation example, the existing trade between the original parties must be downsized at the same time as the trade with the new party is instantiated. Trade compression is another example, that involves multiple before trades being downsized or terminated and new trades being created between multiple parties, all of which must happen concurrently.
"
What is Reset in event model of the common domain model,"In many cases, a trade relies on the value of an observable which will become known in the future: for instance, a floating rate observation at the beginning of each period in the case of a Interest Rate Swap, or the equity price at the end of each period in an Equity Swap. This reset information is captured by the Reset data type and associated to the trade state.

While the reset information is trade-specific, the observation itself is provided by the relevant market data provider independently of any specific trade. Such observation is captured by the Observation data type.

Both the observedValue (in Observation) and the resetValue (in Reset) attributes are specified as a Price type. In the trade, the resettable value must be associated to a variable price attribute. It typically represents a number that is directly used to compute transfer amounts like cashflows.

In addition to the observation value, a reset specifies the date from which the resettable value becomes applicable in the trade's context, which could be different from the observation date if some observation lag applies. Depending on the trade's economic properties, a reset may also depend on several observation values based on some aggregation method - e.g. a compounded interest rate based on daily fixings.

type Reset:
  [metadata key]
  resetValue Price (1..1)
  resetDate date (1..1)
  rateRecordDate date (0..1)
  observations Observation (1..*)
    [metadata reference]
  averagingMethodology AveragingCalculation (0..1)

type Observation:
  [rootType]
  [metadata key]
  observedValue Price (1..1)
  observationIdentifier ObservationIdentifier (1..1)"
What is Transfer in event model of the common domain model,"A transfer is a multi-purpose object that represents the transfer of any asset, including cash, from one party to another. The Transfer object is associated to an enumeration to qualify the status that the transfer is in, from instruction to settlement or rejection.

type TransferState:
  [metadata key]
  [rootType]
  transfer Transfer (1..1)
  transferStatus TransferStatusEnum (0..1)

type Transfer extends TransferBase:
  settlementOrigin SettlementOrigin (0..1)
  resetOrigin Reset (0..1)
  transferExpression TransferExpression (1..1)

type TransferBase:
  identifier Identifier (0..*)
    [metadata scheme]
  quantity NonNegativeQuantity (1..1)
  observable Observable (0..1)
  payerReceiver PartyReferencePayerReceiver (1..1)
  settlementDate AdjustableOrAdjustedOrRelativeDate (1..1)"
Please give me an explnantion of Event model of the common domain model,"The CDM event model provides data structures to represent the lifecycle events of financial transactions. A lifecycle event occurs when a transaction goes through a state transition initiated either by one or both trading parties, by contractual terms, or by external factors. For example, the execution of a trade is the initial event which results in the state of an executed trade. Subsequently, one party might initiate an allocation, both parties might initiate an amendment to a contractual agreement, or a default by an underlying entity on a Credit Default Swap would trigger a settlement according to defined protection terms.

Examples of lifecycle events supported by the CDM Event Model include the following:

Trade execution and confirmation
Clearing
Allocation
Settlement (including any future contingent cashflow payment)
Exercise of options
The representation of lifecycle events in the CDM is based on the following design principles:

A lifecycle event describes a state transition. There must be different before/after trade states based on that lifecycle event.
State transitions are functional and composable. The CDM specifies the entire functional logic to transition from one state to another. The state transition logic of all in-scope events is obtained by composition from a small set of functional building blocks.
The history of the trade state can be reconstructed at any point in the trade lifecycle. The CDM implements a lineage between states as the trade goes through state transitions.
The product underlying the transaction remains immutable. Automated events, for instance resets or cashflow payments, do not alter the product definition. Lifecycle events negotiated between the parties that give rise to a change in the trade economics generate a new instance of the product or trade as part of that specific event.
The state is trade-specific, not product-specific (i.e. the CDM is not an asset-servicing model). The same product may be associated to infinitely many trades, each with its own specific state, between any two parties.
To represent a state transition, the event model is organised around four main components:

Trade state represents the state in the lifecycle that the trade is in, from execution to settlement and maturity.
Primitive operator is the functional building block that is used to compose business events. Each operator describes a fundamental change to the state of a trade going from a before state to an after state and is parameterised by a primitive instruction input.
Business event represents a lifecycle event affecting one or more trades as a composite of primitive instructions. A business event can comprise several instructions, each consisting of a set of primitive instructions applied to a single trade state (before). The resulting trade state (after) can be multiple.
Workflow represents a set of actions or steps that are required to trigger a business event.
The below diagram illustrates the relationship between these components. Each of them is described in the next four sections."
What is Trade State in event model of the common domain model,"A trade state is defined in CDM by the TradeState data type and represents the state of a trade at each stage in its lifecycle. With each trade creation or modification event, a new TradeState instance is created. Chaining together the sequence of TradeState instances then recreates the path each trade took within its lifecycle.

TradeState is a foundational data type in the CDM Event Model as it represents the input and output of any state transition. Therefore, all trade-related information that can change throughout the trade lifecycle are representing within TradeState.

type TradeState:
  [metadata key]
  [rootType]
  trade Trade (1..1)
  state State (0..1)
  resetHistory Reset (0..*)
  transferHistory TransferState (0..*)

While many different types of events may occur through the trade lifecycle, the trade, state, resetHistory and transferHistory attributes are deemed sufficient to describe all of the possible (post-trade) states which may result from lifecycle events. The Trade data type contains the tradable product, which defines all of the economic terms of the transaction as agreed between the parties."
What are the key considerations when managing the allocation of trades in a portfolio?,"When managing the allocation of trades in a portfolio, the key considerations include:

Trade Splitting: Trades often need to be split into smaller portions, especially in scenarios like clearing or allocation. This involves using a split function to divide the original trade into multiple parts, which are then allocated to different accounts or legal entities.

Quantity and Party Changes: After splitting, each portion may have its quantity adjusted and assigned to different counterparties or sub-accounts. This ensures the trade allocation reflects the correct distribution based on the portfolio’s requirements.

Contract Formation: For each allocated trade, it may be necessary to create or update a legally binding contract with the new counterparties, ensuring that the terms of the allocation are clearly defined and agreed upon.

Buyer/Seller Roles: The roles of the buyer and seller must be clearly defined during allocation, particularly when the trade involves settlement terms. Knowing who pays and who receives is crucial for managing the flow of assets or funds.

Settlement Terms: Allocation may involve settlement, where the price and quantity of the allocated trade portions must be settled between different parties. Defining clear settlement terms is essential for ensuring smooth transactions.

Regulatory and Reporting Requirements: It is important to ensure that the allocation aligns with regulatory and reporting standards, particularly in cases where trades need to be reported to regulatory bodies as part of the portfolio's management.

In summary, managing the allocation of trades in a portfolio involves careful consideration of trade splitting, quantity adjustments, party assignments, contract formation, settlement terms, and regulatory compliance. Each step must be precisely managed to ensure accurate and efficient trade allocation."
What are the key differences in how Exchange-Traded Derivatives (ETD) and Over-The-Counter (OTC) derivatives are represented and processed?,"Key Differences in How Exchange-Traded Derivatives (ETD) and Over-The-Counter (OTC) Derivatives Are Represented and Processed:

Standardization vs. Customization:

ETD: These derivatives are standardized contracts traded on regulated exchanges. All contract terms (such as maturity, price, and quantity) are predefined, making them fungible and easy to trade. Their representation typically follows a public standard, and they are processed through centralized clearinghouses, reducing counterparty risk.
OTC Derivatives: OTC derivatives are customized contracts negotiated bilaterally between counterparties. They are not standardized and are tailored to the specific needs of the parties involved. This flexibility in representation requires more detailed tracking of terms and conditions, such as unique contract terms, collateral, and counterparty details.
Collateral Representation:

ETD: Collateral requirements for ETD are set by the exchange and clearinghouse, with predefined margins and collateral rules. The collateral is often in the form of cash or highly liquid securities, and its eligibility criteria are standardized across all trades on the exchange.
OTC Derivatives: Collateral management for OTC derivatives is more complex due to the customized nature of each contract. The collateral eligibility criteria (e.g., asset type, issuer, maturity, concentration limits) can vary between contracts and counterparties. The CDM model provides detailed data structures to specify collateral eligibility, including asset type, issuer rating, and country of origin, which are important in OTC contracts.
Clearing and Settlement:

ETD: All trades are cleared through a centralized clearinghouse, which acts as the counterparty to both sides of the trade. This ensures uniform settlement rules and reduces counterparty risk. Settlement terms are standardized, and the direction of payment and delivery is clearly defined using simple buyer/seller rules.
OTC Derivatives: In OTC trades, clearing is often bilateral, though some trades are now cleared through central counterparties (CCPs) under regulatory reforms like Dodd-Frank. Settlement terms are negotiated and can vary by contract, requiring more complex BuyerSeller structures in the model to specify which party pays or receives based on the custom terms.
Regulatory and Reporting Requirements:

ETD: Regulatory reporting for ETD is straightforward due to the standardized nature of the contracts and the centralized clearing process. Exchanges report trades to regulators, and reporting data is uniform across all market participants.
OTC Derivatives: Regulatory reporting for OTC derivatives is more complex, requiring detailed tracking of custom contract terms, collateral, and counterparty risk. The CDM model provides a flexible structure to capture this information, which is essential for regulatory reporting under frameworks like EMIR, Dodd-Frank, and Basel III.
Complexity and Flexibility:

ETD: ETD contracts are simpler and less flexible, with pre-defined terms, making them easier to process but less customizable.
OTC Derivatives: OTC derivatives offer greater flexibility, allowing for highly customized contracts that cater to specific needs, but this also makes them more complex to represent and process. The CDM model's ability to capture the detailed attributes of assets, issuers, and collateral is critical for managing this complexity.
In summary, ETD are standardized, exchange-traded contracts with simpler collateral and clearing processes, while OTC derivatives are customized, bilaterally negotiated contracts that require more complex collateral management, clearing, and reporting mechanisms. The CDM model helps represent and manage these complexities, particularly for OTC derivatives."
"What level of detail is expected in minutes, especially regarding attribution of speakers?","According to the FINOS minutes policy:

The minutes of each meeting should capture all of the following:

Roll call - everyone who attended the meeting
For each agenda item:
A brief summary of the matter discussed (one sentence is often enough)
Any significant positions/proposals put forward (one sentence each is often enough)
A record of any decisions made or actions taken, including a record of the vote (i.e. votes in favor, votes against, and abstentions)
Any action items assigned, including the assignee and the deadline (if any)"
How does attribution work in minutes? Will my name be included in the public minutes? My employer’s?,"According to the FINOS minutes policy:

Minutes should not attribute any statement to an individual or organization without their express prior approval. This is to ensure that people feel free to speak candidly."""
Are meetings recorded?,"Yes, FINOS automatically captures a private recording of scheduled working group meetings. The primary purpose of these recordings is to make meeting transcripts available to working group chairs for the purpose of preparing minutes. Recordings are not made available to anyone outside the Foundation, unless working group members have been notified in advance (such as when a guest presentation is being recorded)."