Question,Answer
How are settlement instructions generated and processed after a clearing event?,"After a clearing event, settlement instructions are generated and processed using several key components in the trade lifecycle:

PriceQuantity: This data type contains the trade's price, quantity, and potentially settlement terms, which are crucial for defining the settlement. It ensures that the price and quantity of the trade are settled according to the pre-defined conditions.

SettlementTerms: This object outlines the specific details for settlement, such as whether it involves cash or physical settlement, the settlement date, currency, and the type of transfer (e.g., delivery-versus-payment). These parameters are crucial for finalizing the settlement.

BuyerSeller: This data type specifies the direction of the settlement flows, indicating which party is the buyer (paying the price and receiving the quantity) and which is the seller (delivering the quantity and receiving the price).

PayoutBase: This provides a structure for attributes like priceQuantity and settlementTerms to ensure consistency across different settlement scenarios.

In summary, settlement instructions are generated by combining the price, quantity, buyer/seller roles, and settlement terms, ensuring the proper execution of the settlement after the clearing event."
"How does the model manage Positions, including adjustments and settlements?","Position Representation:

The State data type defines the state of a trade at any point in its lifecycle, including open and closed positions. For position keeping, trades have multiple state dimensions, such as positionState and closedState. These states allow the model to track whether a trade is still active (open) or has been settled or closed (e.g., through novation or termination).
Adjustments to Positions:

The model handles position adjustments through primitive operators, such as split or quantity changes. For example, in the case of a novation or partial allocation, a trade may be split into multiple parts, each reflecting an adjustment to the original position. The quantity change function applies to these post-split trades, ensuring the total quantity is properly distributed across the new positions.
Any treatment functions (e.g., haircuts, concentration limits) can also be applied to adjust the valuation or eligibility of collateral associated with a position. These adjustments ensure the position remains compliant with regulatory requirements or internal portfolio rules.
Settlement Management:

Settlements are handled by the SettlementTerms data type. This structure specifies the settlement terms for trades, such as the settlement type (cash or physical), currency, date, and whether the settlement is delivery-versus-payment or payment-versus-payment. For example, in an FX forward transaction, the settlement terms will define the amounts and timing of payments in each currency.
The BuyerSeller data type captures the direction of the settlement, specifying which counterparty pays the price and which counterparty delivers the quantity. This ensures the model accurately processes the settlement flows, whether it's cash or physical delivery.
Lifecycle Events:

Throughout the trade's lifecycle, the model applies event qualification functions to manage how positions transition from one state to another (e.g., from open to settled or closed). These functions ensure that events like novation, early termination, or contract formation are properly recorded and processed within the tradeâ€™s lifecycle.
Tracking Closed Positions:

When a position is settled or closed (due to maturity, novation, or termination), the ClosedState attribute records the closure. This allows the model to keep an accurate record of all positions, including those that are no longer active.
In summary, the CDM model manages positions by tracking the trade's state, using primitive functions to handle adjustments, and applying settlement terms for closing trades. The model ensures that positions are properly adjusted, settled, and reported across their lifecycle."
What is FINOS CDM Distribution,"The FINOS CDM distribution is openly accessible to all industry participants, subject to the FINOS CDM open source licence. This distribution is fully downloadable.

The FINOS CDM distribution comprises three main sets of components:

Model definition, which corresponds to the model as expressed in the Rosetta DSL and contained into a set of .rosetta files organised as namespaces. The primary dimensions of the model are listed below and further described in the common-domain-model of the documentation.
Product
Event
Legal Agreement
Process
Reference Data
Mapping (Synonym)
Executable code distribution, automatically generated from the model definitions expressed in the Rosetta DSL using available code generators. Once a code generator is implemented for a particular language, the corresponding code generation is included as part of the CDM build and release process, allowing the CDM to be automatically distributed in that language going forward.
Default implementation, comprising manually-written code (in Java) which, combined with the auto-generated code, provides a complete implementation of the model. This hand-written code is distributed together with the CDM to facilitate adoption by firms, which can directly use the CDM distribution to set-up and test an implementation. The default implementation can be used in its original state or be disabled or extended by industry participants in their implementations. For example, the default implementation uses the de-facto Java hash function to support cross-referencing in the CDM, but firms may elect to use an alternative implementation."
What is measure in product model of the common domain model,"A measure is a basic component that is useful in the definition of price and quantity (both things that can be measured) and consists of two attributes:

value, which is defined as a number and could be a price or a quantity
unit, which defines the unit in which that value is expressed
MeasureBase defines the basic structure of a measure in which both attributes are optional. Various other data types that extend MeasureBase can further constrain the existence of those attributes: for instance, a Measure requires the value attribute to be present (but unit is still optional because a measure could be unit-less)."
What is price in product model of the common domain model,"The PriceSchedule data type extends the MeasureSchedule data type with the addition of the priceExpression and perUnitOf attributes, which together further qualify the price.Note that the conditions for this data type are excluded from the snippet above for purposes of brevity.

The Price data type further constrains the PriceSchedule data type by requiring the datedValue attribute to be absent."
What is quantity in product model of the common domain model,"The QuantitySchedule data type also extends the MeasureSchedule data type with the addition of an optional multiplier attributes. It also requires the unit attribute to exist, i.e. a quantity cannot be unit-less. The NonNegativeQuantitySchedule data type further constrains it by requiring that all the values are non-negative.The inherited attributes of value, unit and datedValue (in case the quantity is provided as a schedule) are sufficient to define a quantity in most cases.

The additional multiplier attribute that is provided for the QuantitySchedule data type allows to further qualify the value. This is needed for listed contracts or other purposes, as shown below. In this example, the trade involves the purchase or sale of 200 contracts of the WTI Crude Oil futures contract on the CME. Each contract represents 1,000 barrels, therefore the total quantity of the trade is for 200,000 barrels.The frequency attribute is used in a similar way when a quantity may be defined based on a given time period, e.g. per hour or per day. In this case, the quantity needs to be multiplied by the size of the relevant period where it applies, e.g. a number of days, to get the total quantity."
What is Observable in product model of the common domain model,"The Observable data type specifies the reference object to be observed for a price, which could be an underlying asset or a reference such as an index.

The Observable data type requires the specification of either a rateOption (i.e. a floating rate index), commodity, productIdentifier, or currencypair. This choice constraint is supported by specifying a one-of condition"
What is Trade in event model of the common domain model,"The Trade data type defines the outcome of a financial transaction between parties, where the terms are primarily reflected in the tradable product. Additionally, Trade includes attributes such as the trade date, transacting parties, and settlement terms. Some attributes, such as the parties, may already be defined in a workflow step or business event and can simply be referenced in Trade.

type Trade:
  [metadata key]
  tradeIdentifier TradeIdentifier (1..*)
  tradeDate date (1..1)
    [metadata id]
  tradeTime TimeZone (0..1)
    [metadata id]
  tradableProduct TradableProduct (1..1)
  party Party (0..*)
  partyRole PartyRole (0..*)
  executionDetails ExecutionDetails (0..1)
  contractDetails ContractDetails (0..1)
  clearedDate date (0..1)
    [deprecated]
  collateral Collateral (0..1)
  account Account (0..*)
    [deprecated]

Note: Attributes within Trade and ContractDetails incorporate elements from FpML's trade confirmation view, whereas the TradableProduct data type corresponds to FpML's pre-trade view. The TradableProduct data type is further detailed in the tradable-product section of the documentation.

Additionally, Trade supports the representation of specific execution or contractual details via the executionDetails and contractDetails attributes.
ExecutionDetails
The ExecutionDetails data type represents details applicable to trade executions and includes attributes that describe the execution venue and execution type. Not all trades will have been 'executed', such as those created from a Swaption Exercise event. In those cases, the executionDetails attributes on Trade is expected to be empty.

type ExecutionDetails:
  [metadata key]
  executionType ExecutionTypeEnum (1..1)
  executionVenue LegalEntity (0..1)
  packageReference IdentifiedList (0..1)

  condition ExecutionVenue:
    if executionType = ExecutionTypeEnum -> Electronic
    then executionVenue exists

ContractDetails
ContractDetails are only applicable to trades on contractual products and are typically provided at or prior to trade confirmation.

type ContractDetails:
  [metadata key]
  documentation LegalAgreement (0..*)
  governingLaw GoverningLawEnum (0..1)
    [metadata scheme]"
What is State in event model of the common domain model,"The State data type defines the state of a trade at a point in the Trade's life cycle. Trades have many state dimensions, all of which are represented here. For example, states useful for position keeping are represented alongside those needed for regulatory reporting.

type State:
  closedState ClosedState (0..1)
  positionState PositionStatusEnum (0..1)

When a trade is closed, it is necessary to record that closure as part of the trade state.

For instance in a full novation scenario, the initial state is a single TradeState and the resulting state is two TradeState. The first resulting TradeState represents a new contract, which is the same as the original but where one of the parties has been changed, and the second resulting TradeState is the original contract, now marked as closed.

The ClosedState data type (enclosed within State) captures this closed state and defines the reason for closure.

enum ClosedStateEnum:
  Allocated
  Cancelled
  Exercised
  Expired
  Matured
  Novated
  Terminated"
What is Primitive Operator in event model of the common domain model,"Primitive operators are functional building blocks used to compose business events. Each primitive operator describes a fundamental state transition that applies to a trade.

There are nine fundamental operations on trade state. Other than split and execution, they each impact separate attributes of a trade state and are therefore independent of each other.

execution: instantiates a new trade.
quantity change: changes the quantity (and/or price) of a trade
terms change: changes the terms of the product of a trade
party change: changes a party on a trade
exercise: exercises an option embedded in a trade
contract formation: associates a legal agreement to a trade
reset: changes a trade's resettable value based on an observation
transfer: transfers some asset (cash, security, commodity) from one party to another
split: splits a trade into multiple identical trades"
What is Primitive Function in event model of the common domain model,"A primitive operator is represented by a primitive function that takes a before trade state as input and returns an after trade state as output, both of type TradeState. The only exceptions to this rule are:

execution, for which there is no before state since its purpose is to instantiate a new trade, and
split, which results in multiple trade states as copies of the original trade.
All primitive functions are prefixed by Create_ followed by the name of the primitive operator. The business logic of primitive functions is fully implemented. An example of primitive function, for the PartyChange primitive, is illustrated below.

func Create_PartyChange:
  inputs:
    counterparty Counterparty (1..1)
    ancillaryParty AncillaryParty (0..1)
    partyRole PartyRole (0..1)
    tradeId TradeIdentifier (1..*)
    originalTrade TradeState (1..1)
  output:
    newTrade TradeState (1..1)"
What is Primitive Instruction in event model of the common domain model,"Primitive functions take additional inputs alongside the before trade state to specify the parameters of the state transition. Each primitive operator is associated to a primitive instruction data type that contains the function's required parameters as attributes - illustrated below using the same PartyChange example.

type PartyChangeInstruction:
  counterparty Counterparty (1..1)
  ancillaryParty AncillaryParty (0..1)
  partyRole PartyRole (0..1)
  tradeId TradeIdentifier (1..*)

The PrimitiveInstruction data type allows to build composite primitive instructions and therefore compose primitive operators. This data type contains one instruction attribute for each of the possible nine primitive instruction types - aligned onto the nine fundamental primitive operators.

type PrimitiveInstruction:
  contractFormation ContractFormationInstruction (0..1)
  execution ExecutionInstruction (0..1)
  exercise ExerciseInstruction (0..1)
  partyChange PartyChangeInstruction (0..1)
  quantityChange QuantityChangeInstruction (0..1)
  reset ResetInstruction (0..1)
  split SplitInstruction (0..1)
  termsChange TermsChangeInstruction (0..1)
  transfer TransferInstruction (0..1)"
What is Primitive Composition in event model of the common domain model,"The separation between the before trade state and primitive instructions allows to compose primitive operators. Primitive operators can be chained by applying a composite primitive instruction to a single trade state, The Create_TradeState function performs such composition of primitive operators. It takes a single trade state and a composite primitive instruction as inputs and returns a single trade state. The before trade state input is optional, in which case a new execution must be specified in the instructions.

This function applies each of the primitive operators (other than split) to the trade state in the order listed in the primitive operator section. Apart from execution which, when present, must always be applied first, the order does not affect the outcome because each primitive operator impacts a different part of the trade state.

func Create_TradeState:
  inputs:
    primitiveInstruction PrimitiveInstruction (0..1)
    before TradeState (0..1)
  output:
    after TradeState (1..1)

"
Why a Process Model,"The CDM lays the foundation for the standardisation, automation and inter-operability of industry processes. Industry processes represent events and actions that occur through the transaction's lifecycle, from negotiating a legal agreement to allocating a block-trade or calculating settlement amounts.

While ISDA defines the protocols for industry processes in its library of ISDA Documentation, differences in the implementation minutia may cause operational friction between market participants. Evidence shows that even when calculations are defined in mathematical notation (for example, day count fraction formulae which are used when calculating interest rate payments) can be a source of dispute between parties in a transaction."
What Is the Process Model,"The CDM Process Model has been designed to translate the technical standards that support those industry processes into a standardised machine-readable and machine-executable format.

Machine readability and executability is crucial to eliminate implementation discrepancy between market participants and increase interoperability between technology solutions. It greatly minimises the cost of adoption and provides a blueprint on which industry utilities can be built."
How Does the Process Model Work,"The data and process model definitions of the CDM are systematically translated into executable code using purpose-built code generation technology. The CDM executable code is available in a number of modern, widely adopted and freely available programming languages and is systematically distributed as part of the CDM release.

The code generation process is based on the Rosetta DSL and is further described in the Code Generation Section, including an up-to-date list of available languages. Support for further languages can be added as required by market participants.

"